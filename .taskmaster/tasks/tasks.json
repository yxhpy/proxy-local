{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "项目初始化与依赖设置",
        "description": "创建一个新的 Node.js 项目，配置 package.json，并安装构建 CLI 工具所需的核心依赖。",
        "details": "使用 `npm init -y` 初始化项目。安装 `commander` 用于命令行参数解析，以及 `localtunnel` 作为核心的内网穿透服务。在 `package.json` 中设置 `type: 'module'` 以使用 ES模块语法，并配置 `bin` 字段，将 `uvx` 命令指向主执行文件，例如：`\"bin\": { \"uvx\": \"./bin/index.js\" }`。",
        "testStrategy": "运行 `npm install` 确保所有依赖项都已正确安装，并检查 `package.json` 文件是否包含正确的配置。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "初始化 Node.js 项目",
            "description": "创建项目目录并使用 npm 初始化一个新的 Node.js 项目，生成一个默认的 `package.json` 文件。",
            "dependencies": [],
            "details": "在终端中创建一个新的项目文件夹，进入该文件夹，然后运行 `npm init -y` 命令。这将快速生成一个基础的 `package.json` 文件，作为项目配置的起点。",
            "status": "done",
            "testStrategy": "检查项目文件夹中是否已成功生成 `package.json` 文件，并且其内容是有效的 JSON 格式。"
          },
          {
            "id": 2,
            "title": "安装核心依赖项",
            "description": "安装构建 CLI 工具所需的两个核心 npm 包：`commander` 用于解析命令行参数，`localtunnel` 用于实现内网穿透功能。",
            "dependencies": [],
            "details": "在项目根目录下，打开终端并运行命令 `npm install commander localtunnel`。这将把这两个包添加到项目的依赖中。",
            "status": "done",
            "testStrategy": "检查 `package.json` 文件中的 `dependencies` 字段是否已包含 `commander` 和 `localtunnel`。同时确认 `node_modules` 目录已创建且包含这两个包的文件夹。"
          },
          {
            "id": 3,
            "title": "配置 `package.json` 以支持 ES 模块",
            "description": "修改 `package.json` 文件，添加 `type: 'module'` 字段，以便在整个项目中使用现代的 ES 模块语法（`import`/`export`）。",
            "dependencies": [],
            "details": "手动编辑 `package.json` 文件，在文件的顶层（与 `name`, `version` 等字段同级）添加一行 `\"type\": \"module\"`。",
            "status": "done",
            "testStrategy": "创建一个临时的 JS 文件，在其中使用 `import` 语法。尝试用 `node` 命令运行该文件，确认不会因模块系统不匹配而报错。"
          },
          {
            "id": 4,
            "title": "配置 `bin` 字段以定义 CLI 命令",
            "description": "在 `package.json` 中配置 `bin` 字段，将自定义命令 `uvx` 链接到项目的可执行入口文件，使其可以通过 npm 进行全局安装和调用。",
            "dependencies": [],
            "details": "编辑 `package.json` 文件，添加 `bin` 字段，其值为一个对象：`{ \"uvx\": \"./bin/index.js\" }`。这会告诉 npm，当用户安装此包时，需要创建一个名为 `uvx` 的可执行命令。",
            "status": "done",
            "testStrategy": "在项目根目录运行 `npm link`。然后，在终端的任何位置尝试运行 `uvx` 命令。此时预期会报错（因为文件尚未创建），但不应是“命令未找到”的错误。"
          },
          {
            "id": 5,
            "title": "创建入口文件及目录结构",
            "description": "根据 `bin` 字段的配置，创建 `bin` 目录以及主执行文件 `index.js`，并添加 shebang 行使其能够作为脚本直接执行。",
            "dependencies": [],
            "details": "在项目根目录创建一个名为 `bin` 的文件夹。在 `bin` 文件夹内，创建一个名为 `index.js` 的文件。在 `index.js` 文件的第一行添加 `#!/usr/bin/env node`，以指定该文件应由 Node.js 环境执行。",
            "status": "done",
            "testStrategy": "在 `bin/index.js` 文件中添加一行 `console.log('CLI is running!');`。运行 `npm link` 后，在终端执行 `uvx` 命令，验证是否能看到输出 'CLI is running!'。"
          }
        ]
      },
      {
        "id": 2,
        "title": "构建基础 CLI 命令结构",
        "description": "使用 `commander` 库设置 `proxy-local <port>` 命令，并处理用户输入的端口参数。",
        "details": "在主执行文件（例如 `bin/index.js`）中，引入 `commander`。定义一个程序，添加一个名为 `proxy-local` 的命令，它接受一个必需的参数 `<port>`。添加对端口参数的初步验证，确保它是一个有效的数字。伪代码：\n`import { Command } from 'commander';\nconst program = new Command();\nprogram\n  .command('proxy-local <port>')\n  .description('Proxy a local port to a public URL')\n  .action((port) => {\n    console.log(`Port to proxy: ${port}`);\n  });\nprogram.parse(process.argv);`",
        "testStrategy": "在本地运行 `node ./bin/index.js proxy-local 8080`，验证程序是否能正确接收并打印端口号 `8080`。测试无效输入，例如 `uvx proxy-local abc`，并确保程序能给出提示或优雅退出。",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "创建主执行文件并引入 commander",
            "description": "在 `bin` 目录下创建 `index.js` 文件，添加 shebang (`#!/usr/bin/env node`) 以确保其可执行性，并引入 `commander` 库来初始化命令程序实例。",
            "dependencies": [],
            "details": "创建 `bin/index.js` 文件。在文件顶部添加 `#!/usr/bin/env node`。然后，使用 `import { Command } from 'commander';` 引入库，并初始化一个 `Command` 实例：`const program = new Command();`。确保该文件在 `package.json` 的 `bin` 字段中被正确引用。",
            "status": "done",
            "testStrategy": "检查 `bin/index.js` 文件是否存在，并且内容包含 shebang 和 commander 的引入语句。运行 `node ./bin/index.js --version` 不应报错（即使没有定义版本）。"
          },
          {
            "id": 2,
            "title": "定义 `proxy-local <port>` 命令、参数和描述",
            "description": "使用 `program.command()` 方法定义 `proxy-local` 命令，并指定它接受一个名为 `<port>` 的必需参数，同时为其添加清晰的描述信息。",
            "dependencies": [
              "2.1"
            ],
            "details": "在 `program` 实例上链式调用 `.command('proxy-local <port>')` 来定义命令。接着，使用 `.description('Proxy a local port to a public URL')` 为该命令添加用户友好的描述。",
            "status": "done",
            "testStrategy": "运行 `node ./bin/index.js --help`，验证输出中是否包含 `proxy-local <port>` 命令及其描述。"
          },
          {
            "id": 3,
            "title": "实现基础的 action 处理函数",
            "description": "为 `proxy-local` 命令添加一个 `.action()` 处理函数，该函数能够接收用户传入的端口参数，并将其简单地打印到控制台以进行初步验证。",
            "dependencies": [
              "2.2"
            ],
            "details": "在命令定义后链式调用 `.action((port) => { console.log(`Port to proxy: ${port}`); });`。此函数将作为命令执行时的回调，`port` 参数将自动接收用户在命令行中输入的值。",
            "status": "done",
            "testStrategy": "运行 `node ./bin/index.js proxy-local 8080`，检查控制台是否正确输出 `Port to proxy: 8080`。"
          },
          {
            "id": 4,
            "title": "在 action 中添加端口号有效性验证",
            "description": "在 `action` 处理函数内部，增加逻辑来验证用户输入的 `port` 是否为一个有效的数字。如果输入无效，则向用户显示错误信息并终止程序。",
            "dependencies": [
              "2.3"
            ],
            "details": "在 `action` 函数的开头，使用 `const portNumber = parseInt(port, 10);` 将输入转换为数字。然后使用 `if (isNaN(portNumber))` 进行检查。如果验证失败，则通过 `console.error('错误: 端口必须是一个有效的数字。');` 提示用户，并调用 `process.exit(1);` 异常退出。",
            "status": "done",
            "testStrategy": "运行 `node ./bin/index.js proxy-local abc`，验证程序是否打印错误信息并退出。运行 `node ./bin/index.js proxy-local 3000`，验证程序是否正常执行。"
          },
          {
            "id": 5,
            "title": "调用 `program.parse` 使命令生效",
            "description": "在脚本的末尾调用 `program.parse(process.argv)`，这是触发 `commander` 解析命令行参数并执行相应命令和动作的关键步骤。",
            "dependencies": [
              "2.4"
            ],
            "details": "在所有命令定义和配置的最后，添加 `program.parse(process.argv);`。这将启动 `commander` 的解析引擎，使其能够根据用户输入匹配到已定义的 `proxy-local` 命令并执行其 `action`。",
            "status": "done",
            "testStrategy": "确保所有之前的测试用例（如 `proxy-local 8080` 和 `proxy-local abc`）在添加此行代码后仍然按预期工作，证明解析和执行流程已完整建立。"
          }
        ]
      },
      {
        "id": 3,
        "title": "封装内网穿透核心逻辑",
        "description": "创建一个独立的模块，负责调用 `localtunnel` 库来建立从本地端口到公共 URL 的隧道。",
        "details": "创建一个新文件 `src/tunnel.js`。在该文件中，导出一个异步函数 `createTunnel(port)`。此函数将调用 `localtunnel` 包，并返回一个包含公共 URL 的 Promise。示例：\n`import localtunnel from 'localtunnel';\nexport async function createTunnel(port) {\n  const tunnel = await localtunnel({ port });\n  return tunnel.url;\n}`\n需要处理 `localtunnel` 可能抛出的异常。",
        "testStrategy": "编写一个简单的单元测试脚本，调用 `createTunnel` 函数并传入一个有效的、正在运行的本地服务端口，断言它是否返回一个格式正确的 URL 字符串（例如 `https://*.loca.lt`）。",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "创建 `src/tunnel.js` 文件并定义函数骨架",
            "description": "初始化模块文件，并导出一个空的异步函数 `createTunnel(port)`，为后续逻辑实现奠定基础。",
            "dependencies": [],
            "details": "在项目的 `src` 目录下创建一个名为 `tunnel.js` 的新文件。在该文件中，定义并导出一个名为 `createTunnel` 的异步函数，该函数接受一个 `port` 参数。函数体暂时可以为空或只包含一个占位符，例如 `export async function createTunnel(port) {}`。",
            "status": "done",
            "testStrategy": "检查文件 `src/tunnel.js` 是否已创建，并且其中包含 `export async function createTunnel(port)` 的正确函数签名。"
          },
          {
            "id": 2,
            "title": "引入 `localtunnel` 库并实现核心调用",
            "description": "在 `createTunnel` 函数内部，实际调用 `localtunnel` 库来根据用户指定的端口创建隧道。",
            "dependencies": [
              "3.1"
            ],
            "details": "在 `src/tunnel.js` 文件顶部，使用 `import localtunnel from 'localtunnel';` 引入依赖。在 `createTunnel` 函数内部，使用 `const tunnel = await localtunnel({ port });` 来调用库并等待隧道建立。",
            "status": "done",
            "testStrategy": "此步骤的成功将由后续子任务的测试来验证，因为它本身不产生可直接断言的输出。"
          },
          {
            "id": 3,
            "title": "从隧道对象中提取并返回公共 URL",
            "description": "在成功创建隧道后，从 `localtunnel` 返回的对象中获取 `url` 属性，并将其作为函数的返回值。",
            "dependencies": [
              "3.2"
            ],
            "details": "在获取到 `tunnel` 对象后，添加 `return tunnel.url;` 语句，以确保函数返回一个包含公共 URL 的 Promise。",
            "status": "done",
            "testStrategy": "通过一个临时脚本调用该函数，并打印返回值，手动验证其是否为一个有效的 URL 字符串。"
          },
          {
            "id": 4,
            "title": "添加 `try...catch` 块以处理基本异常",
            "description": "为 `localtunnel` 调用添加基础的错误处理机制，以捕获在隧道创建过程中可能发生的异常，防止程序意外崩溃。",
            "dependencies": [
              "3.2"
            ],
            "details": "使用 `try...catch` 结构将 `await localtunnel(...)` 调用包裹起来。在 `catch` 块中，捕获错误对象，并暂时使用 `console.error` 打印错误信息，然后重新抛出异常 `throw error;`，以便上层调用者能够处理它。",
            "status": "done",
            "testStrategy": "尝试传入一个无效的端口号（如 99999）来调用函数，并验证程序是否会捕获异常并打印错误信息，而不是直接崩溃。"
          },
          {
            "id": 5,
            "title": "编写单元测试验证成功路径",
            "description": "根据任务要求，创建一个单元测试脚本，用于验证 `createTunnel` 函数在正常情况下的行为是否符合预期。",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "创建一个测试文件（如 `tunnel.test.js`）。在测试用例中，首先启动一个临时的本地 HTTP 服务器。然后调用 `createTunnel` 函数，并传入该服务器的端口。使用断言来验证返回的 URL 是一个字符串，并且其格式符合 `localtunnel` 的规范（例如，`url.startsWith('https://')`）。测试结束后，确保关闭临时服务器。",
            "status": "done",
            "testStrategy": "运行单元测试套件，并确认此测试用例能够成功通过。"
          }
        ]
      },
      {
        "id": 4,
        "title": "集成 CLI 命令与穿透逻辑",
        "description": "将 `proxy-local` 命令与 `createTunnel` 函数连接起来，当用户执行命令时，实际启动隧道进程。",
        "details": "修改 `bin/index.js` 中的 `action` 处理函数。将其改为 `async` 函数，并在其中调用从 `src/tunnel.js` 导入的 `createTunnel` 函数。使用 `await` 等待隧道建立成功并获取返回的 URL。伪代码：\n`...action(async (port) => {\n  try {\n    const url = await createTunnel(parseInt(port, 10));\n    // 后续步骤将在这里打印 URL\n  } catch (err) {\n    // 后续步骤将在这里处理错误\n  }\n});`",
        "testStrategy": "启动一个本地Web服务器（例如使用 `npx http-server -p 8080`）。然后运行 `node ./bin/index.js proxy-local 8080`。在代码中设置断点或使用 `console.log` 检查是否成功调用了 `createTunnel` 并获取了 URL。",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "在 CLI 文件中导入隧道模块",
            "description": "为了在 `proxy-local` 命令的处理函数中调用隧道创建逻辑，首先需要在 `bin/index.js` 文件中导入 `src/tunnel.js` 模块暴露的 `createTunnel` 函数。",
            "dependencies": [],
            "details": "在 `bin/index.js` 文件的顶部，根据项目配置（ESM 或 CJS），添加 `import { createTunnel } from '../src/tunnel.js';` 或 `const { createTunnel } = require('../src/tunnel.js');`。",
            "status": "done",
            "testStrategy": "确认导入语句没有导致语法错误，并且在后续步骤中 `createTunnel` 变量可以被正确引用。"
          },
          {
            "id": 2,
            "title": "将 `action` 处理函数转换为异步函数",
            "description": "由于 `createTunnel` 是一个返回 Promise 的异步函数，为了能够使用 `await` 语法来等待其结果，必须将 `commander` 命令的 `action` 回调函数声明为 `async`。",
            "dependencies": [],
            "details": "找到 `program.command('proxy-local <port>').action(...)` 这行代码，将其回调函数从 `(port) => { ... }` 修改为 `async (port) => { ... }`。",
            "status": "done",
            "testStrategy": "修改后运行 CLI 命令，确保 `commander` 能够正确执行异步的 `action` 函数而不会报错。"
          },
          {
            "id": 3,
            "title": "在 `action` 函数中调用 `createTunnel`",
            "description": "在异步的 `action` 函数内部，调用已导入的 `createTunnel` 函数，并将从命令行获取的端口号作为参数传递给它。",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "在 `action` 函数体内部，添加调用代码。由于命令行的参数是字符串类型，需要使用 `parseInt(port, 10)` 将其转换为数字。示例：`const url = await createTunnel(parseInt(port, 10));`。",
            "status": "done",
            "testStrategy": "在 `createTunnel` 函数内部设置一个 `console.log` 或断点，运行命令 `node ./bin/index.js proxy-local 8080`，验证该函数是否被成功调用，并且接收到的 `port` 参数是否为数字 `8080`。"
          },
          {
            "id": 4,
            "title": "实现基础的 `try...catch` 错误处理结构",
            "description": "为 `createTunnel` 的调用添加 `try...catch` 块，以捕获可能发生的异常（如网络错误、服务不可用等），防止程序因未处理的 Promise rejection 而崩溃。",
            "dependencies": [
              "4.3"
            ],
            "details": "将 `await createTunnel(...)` 调用语句包裹在 `try` 块中。在 `catch (err)` 块中，暂时添加一个简单的错误日志输出，例如 `console.error('创建隧道失败:', err.message);` 和 `process.exit(1);`。",
            "status": "done",
            "testStrategy": "通过模拟一个错误场景（例如断开网络连接）来运行命令，验证程序是否能够进入 `catch` 块，打印错误信息并正常退出，而不是崩溃。"
          },
          {
            "id": 5,
            "title": "处理成功情况并向用户显示 URL",
            "description": "当 `createTunnel` 成功返回 URL 后，需要将这个公开可访问的 URL 打印到控制台，明确告知用户隧道已经建立成功。",
            "dependencies": [
              "4.3",
              "4.4"
            ],
            "details": "在 `try` 块中，紧跟在 `await createTunnel(...)` 语句之后，添加 `console.log` 语句来显示获取到的 `url`。可以使用一些友好的提示语，例如 `console.log(`隧道已就绪！公网访问地址: ${url}`);`。",
            "status": "done",
            "testStrategy": "启动一个本地 Web 服务器（如 `npx http-server -p 8080`），然后运行 `node ./bin/index.js proxy-local 8080`。验证控制台是否成功打印出格式正确的 `localtunnel` URL。"
          }
        ]
      },
      {
        "id": 5,
        "title": "实现用户友好的输出",
        "description": "在成功创建隧道后，向用户清晰地显示代理的公共 URL。",
        "details": "安装 `chalk` 库 (`npm install chalk`) 以美化控制台输出。在获取到隧道 URL 后，使用 `console.log` 格式化输出，用醒目的颜色高亮显示 URL。例如：\n`console.log(`\\n✅ Proxy successful!`);\nconsole.log(`Local:  http://localhost:${port}`);\nconsole.log(`Public: ${chalk.green(url)}`);`",
        "testStrategy": "运行 `uvx proxy-local 8080` 命令，并目视检查控制台输出是否清晰、美观，并且公共 URL 是否以高亮颜色显示。",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "增加全面的错误处理",
        "description": "为各种潜在的失败情况添加健壮的错误处理机制，例如端口无效、端口被占用或 `localtunnel` 服务不可用。",
        "details": "在调用 `createTunnel` 的地方使用 `try...catch` 块。在 `catch` 块中，检查错误的类型或消息，并向用户提供有意义的反馈。例如，如果端口无效，提示“端口必须是数字”。如果 `localtunnel` 连接失败，提示“无法连接到穿透服务，请检查网络连接”。可以使用 `chalk.red` 来显示错误消息。",
        "testStrategy": "模拟各种错误场景进行测试：1. 提供一个非数字端口 `uvx proxy-local test`。2. 提供一个未被监听的端口。3. 在断网环境下运行命令。验证每种情况下程序是否都能捕获错误并显示正确的错误信息，而不是崩溃。",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "配置可执行文件和本地测试",
        "description": "确保项目可以作为全局命令正确安装和执行。",
        "details": "在主执行文件 `bin/index.js` 的顶部添加 shebang 行 `#!/usr/bin/env node`。在项目根目录运行 `npm link`，这将创建一个符号链接，允许你在系统的任何地方通过输入 `uvx` 来测试你的 CLI 工具，而无需发布到 npm。",
        "testStrategy": "运行 `npm link` 后，打开一个新的终端窗口，执行 `uvx proxy-local 3000`。验证命令是否能被识别并成功执行，其行为应与 `node ./bin/index.js proxy-local 3000` 完全一致。",
        "priority": "medium",
        "dependencies": [
          1,
          5,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "处理隧道关闭事件",
        "description": "监听 `localtunnel` 的关闭事件，并在隧道意外关闭时通知用户。",
        "details": "修改 `createTunnel` 函数，使其不仅返回 URL，还返回 `tunnel` 对象本身。在主逻辑中，监听 `tunnel.on('close', ...)` 事件。当隧道关闭时，向用户打印一条消息，例如 `console.log('Tunnel closed.')`。同时，优雅地退出进程 `process.exit()`。",
        "testStrategy": "运行工具并建立隧道后，手动访问 `localtunnel` 提供的 URL。某些情况下（如长时间不活动），隧道可能会自动关闭。观察控制台是否打印了关闭信息并正常退出。",
        "priority": "low",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "编写项目文档 (README.md)",
        "description": "创建一个 `README.md` 文件，清晰地说明工具的用途、如何安装以及如何使用。",
        "details": "在项目根目录创建 `README.md` 文件。内容应包括：\n- **项目标题和简介**: 介绍 `uvx` 是一个什么工具。\n- **安装**: `npm install -g <your-package-name>`\n- **使用方法**: 提供清晰的命令示例，`uvx proxy-local 8080`，并解释其作用。\n- **选项**: 如果未来添加了其他选项，也在此处说明。",
        "testStrategy": "让一个不了解该项目的同事或朋友阅读 README，看他们是否能根据文档成功理解、安装和使用该工具。",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "准备发布到 NPM",
        "description": "最终确定 `package.json` 中的所有字段，并准备将该工具作为公共包发布到 npm。",
        "details": "检查并完善 `package.json`：设置一个唯一的 `name`，更新 `version`，填写 `description`、`author`、`license` 和 `keywords` 字段。确保 `main` 和 `files` 字段正确配置，只包含必要的文件（如 `bin`, `src`）。登录 npm (`npm login`) 并运行 `npm publish --access public` 进行发布。",
        "testStrategy": "在发布前，运行 `npm pack` 生成一个 `.tgz` 压缩包。在一个新的空目录中，运行 `npm install ../path/to/your.tgz` 来模拟从 npm 安装。然后测试已安装的命令是否正常工作，以确保打包内容完整且正确。",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "架构设计与提供商抽象层",
        "description": "根据PRD要求，建立一个灵活的提供商管理架构。定义统一的 `TunnelProvider` 接口，并创建一个提供商管理器，用于注册、选择和切换不同的内网穿透服务。",
        "details": "创建 `src/providers/interface.ts` 文件来定义 `TunnelProvider` 接口，应包含 `name`, `createTunnel`, `isAvailable`, `getFeatures` 等方法。然后创建 `src/providers/manager.ts`，实现一个 `ProviderManager` 类，该类维护一个提供商列表，并包含 `selectProvider` 和 `getNextProvider` 等核心逻辑。这是后续所有提供商集成的基础。",
        "testStrategy": "为 `ProviderManager` 编写单元测试，模拟注册和选择提供商的场景，确保其逻辑正确。验证接口定义是否满足所有已知和未来提供商的需求。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "集成 Pinggy 提供商 (P0)",
        "description": "作为最高优先级的任务，集成 Pinggy 作为默认的内网穿透服务，以解决 localtunnel 首次访问需要确认的核心痛点。",
        "details": "安装官方SDK: `npm install @pinggy/pinggy`。在 `src/providers/pinggy.ts` 中实现 `TunnelProvider` 接口。使用 `@pinggy/pinggy` 的 `connect` 方法来创建隧道。需要处理其返回的 URL 和可能发生的连接错误。确保正确捕获并返回 `TunnelResult` 对象。",
        "testStrategy": "编写集成测试，启动一个本地服务，然后调用 Pinggy 提供商的 `createTunnel` 方法，验证是否能成功获取公网 URL，并通过该 URL 访问到本地服务。测试连接失败时的错误处理。",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "优化 CLI 命令接口",
        "description": "更新 `uvx proxy-local` 命令，以支持多提供商选择、列出可用提供商等新功能。",
        "details": "使用 `commander` 库（最新版本）来重构 CLI 参数解析。添加 `--provider <name>` 选项来指定服务商，以及 `--list-providers` 标志来打印所有已注册提供商及其特点。默认行为（不带参数）应触发提供商管理器的默认选择逻辑。示例代码：`program.command('proxy-local <port>').option('-p, --provider <name>', 'Specify a tunnel provider').option('--list-providers', 'List all available providers').action(...)`",
        "testStrategy": "通过命令行手动测试：`uvx proxy-local 8000`, `uvx proxy-local 8000 --provider=pinggy`, `uvx proxy-local --list-providers`。编写自动化脚本来验证不同参数组合下的行为是否符合预期。",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "实现智能回退与提供商选择逻辑",
        "description": "在提供商管理器中实现核心的智能回退功能。当首选提供商失败时，系统应能自动、无缝地尝试下一个可用的提供商。",
        "details": "在 `ProviderManager` 中实现一个 `createTunnelWithFallback` 方法。该方法内部维护一个按优先级排序的提供商列表（例如 `[Pinggy, Serveo, LocalTunnel]`)。它会按顺序尝试调用每个提供商的 `createTunnel` 方法，一旦成功则立即返回结果。如果一个提供商失败，它会捕获错误，记录日志，并继续尝试下一个，直到所有提供商都失败为止。",
        "testStrategy": "编写单元测试，模拟提供商成功和失败的场景。例如，创建一个 mock 的 Pinggy 提供商使其总是抛出错误，验证系统是否会自动尝试下一个（如 Serveo）。集成测试：通过断开网络或使用无效端口来触发真实的回退场景。",
        "priority": "high",
        "dependencies": [
          12,
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "集成 Serveo 提供商",
        "description": "集成 Serveo.net 作为另一个无确认页面的备选方案，通过 SSH 隧道实现。",
        "details": "在 `src/providers/serveo.ts` 中实现 `TunnelProvider` 接口。使用 Node.js 的 `child_process.spawn` 模块来执行 SSH 命令：`ssh -R 80:localhost:<port> serveo.net`。需要监听子进程的 `stdout` 来捕获 Serveo 分配的公网 URL，并监听 `stderr` 和 `exit` 事件来处理错误。由于需要解析输出，正则表达式可能是个好方法，例如 `/Forwarding HTTP traffic from (https:\\[^\\]+)/`。",
        "testStrategy": "集成测试：启动本地服务，调用 Serveo 提供商的 `createTunnel`，验证是否能正确解析出 URL 并成功建立连接。测试当 SSH 命令失败（例如 `ssh` 未安装）或连接被拒绝时的错误处理。",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "保留并重构 LocalTunnel 提供商",
        "description": "将现有的 LocalTunnel 功能重构，使其符合新的 `TunnelProvider` 接口，作为备选方案保留。",
        "details": "安装 `localtunnel` npm 包。在 `src/providers/localtunnel.ts` 中实现 `TunnelProvider` 接口。调用 `localtunnel({ port })` 并处理其返回的 promise。将获取到的 `tunnel.url` 包装在 `TunnelResult` 对象中返回。处理 `localtunnel` 可能抛出的各种异常。",
        "testStrategy": "集成测试：确保在新的架构下，`uvx proxy-local 8000 --provider=localtunnel` 命令能像以前一样正常工作。验证其创建的隧道 URL 确实需要点击确认页面。",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "实现配置管理功能",
        "description": "支持通过配置文件和环境变量来设置默认提供商，以满足高级用户的定制需求。",
        "details": "引入 `cosmiconfig` 库 (`npm install cosmiconfig`) 来统一处理配置。在 `ProviderManager` 初始化时，使用 `cosmiconfig` 搜索 `.uvxrc` 文件或 `uvx` 在 `package.json` 中的字段。同时，检查 `UVX_PROVIDER` 环境变量。配置加载的优先级应为：CLI 参数 > 环境变量 > 配置文件 > 程序默认值。",
        "testStrategy": "创建不同的配置文件（如 `.uvxrc`）和设置环境变量，然后运行命令，验证提供商的选择顺序是否遵循预设的优先级规则。例如，当配置文件设置为 `serveo`，环境变量设置为 `localtunnel` 时，默认应使用 `localtunnel`。",
        "priority": "medium",
        "dependencies": [
          13,
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "优化输出格式与用户体验",
        "description": "根据 PRD 的要求，美化命令行输出，为用户提供更清晰、更有用的信息，如当前提供商、URL、特点等。",
        "details": "创建一个专门的 UI/Logger 模块。在隧道创建成功后，调用此模块来打印格式化的成功信息。可以使用 `chalk` 库来添加颜色，使输出更具可读性。输出内容应动态生成，包含提供商名称、公共 URL、特点（如“无确认页面”）、速度评估和 HTTPS 支持情况。",
        "testStrategy": "手动运行命令并截图，与 PRD 中的输出示例进行比对，确保格式、颜色和信息完全一致。编写快照测试（Snapshot Testing）来锁定输出格式，防止未来被意外修改。",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "完善全局错误处理和重试机制",
        "description": "为所有提供商和核心流程添加健壮的错误处理机制，当隧道创建失败时，向用户显示友好的错误信息和排错建议。",
        "details": "在 `ProviderManager` 的回退逻辑中，对每个提供商的 `createTunnel` 调用都使用 `try...catch` 块。当捕获到错误时，不仅要尝试下一个提供商，还要记录详细的错误信息。如果所有提供商都失败了，应向用户显示一个总结性的错误报告，例如：“所有内网穿透服务商（Pinggy, Serveo, LocalTunnel）均尝试失败。请检查您的网络连接或目标端口 `8000` 是否已启动。”",
        "testStrategy": "单元测试：模拟各种错误情况，如网络断开、端口被占用、提供商服务器宕机等，验证错误信息是否友好且准确。手动测试：故意使用一个未启动的端口号运行命令，检查最终的错误输出是否符合预期。",
        "priority": "medium",
        "dependencies": [
          14,
          15,
          16
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "为未来扩展提供商预留接口",
        "description": "确保当前架构具有良好的可扩展性，方便未来快速添加如 Bore、Staqlab 等新的提供商。",
        "details": "编写一份开发者文档（例如 `CONTRIBUTING.md`），详细说明如何实现一个新的 `TunnelProvider` 接口并将其注册到 `ProviderManager` 中。在代码中为 `ProviderManager` 的提供商列表添加注释，说明如何添加新项。可以创建一个 `src/providers/template.ts` 文件作为新提供商的实现模板。",
        "testStrategy": "代码审查（Code Review）：邀请另一位开发者根据文档尝试添加一个“假的”提供商（mock provider），看流程是否顺畅，文档是否清晰。确保添加新提供商不需要修改管理器核心代码，只需创建新文件并注册即可。",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "架构设计与提供商抽象",
        "description": "创建内网穿透服务的核心抽象层，包括定义统一的 `TunnelProvider` 接口和提供商管理器，为支持多种服务商奠定基础。",
        "details": "定义一个 `TunnelProvider` TypeScript 接口，包含 `name`, `createTunnel`, `isAvailable`, `getFeatures` 等方法。创建一个 `ProviderManager` 类，负责注册、获取和管理所有可用的提供商实现。此设计将解耦核心逻辑与具体提供商的实现。伪代码：\n```typescript\ninterface TunnelProvider {\n  name: string;\n  createTunnel(port: number, options?: any): Promise<{ url: string }>;\n  isAvailable(): Promise<boolean>;\n}\n\nclass ProviderManager {\n  private providers: Map<string, TunnelProvider> = new Map();\n  register(provider: TunnelProvider) { this.providers.set(provider.name, provider); }\n  get(name: string): TunnelProvider | undefined { return this.providers.get(name); }\n  getDefault(): TunnelProvider { /* ... */ }\n}\n```",
        "testStrategy": "单元测试 `ProviderManager` 的注册和获取功能。验证 `TunnelProvider` 接口定义的完整性。模拟不同的提供商实现并进行注册测试。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "CLI 命令结构重构",
        "description": "更新 `uvx proxy-local` 命令以支持新的多提供商参数，如 `--provider`, `--list-providers` 和 Cloudflare 特定选项。",
        "details": "使用 `commander` 或 `yargs` 等库来重构 CLI 参数解析逻辑。添加 `--provider` 选项，接受 `cloudflare`, `pinggy` 等值。添加 `--list-providers` 标志，用于列出所有已注册的提供商。为 Cloudflare 添加 `--cloudflare-login`, `--cloudflare-logout`, `--cloudflare-custom` 等专用命令。确保旧命令 `uvx proxy-local 8000` 能平滑过渡到默认使用 Cloudflare。",
        "testStrategy": "单元测试 CLI 参数解析。运行命令 `uvx proxy-local 8000 --provider=cloudflare` 并验证解析出的选项是否正确。测试 `uvx proxy-local --list-providers` 是否能触发正确的处理函数。测试无效提供商名称的错误处理。",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "集成 Cloudflare Tunnel (临时模式)",
        "description": "实现 Cloudflare Tunnel 作为默认提供商，重点是无需登录的临时模式，解决核心的用户体验问题。",
        "details": "创建一个 `CloudflareProvider` 类实现 `TunnelProvider` 接口。使用 `cloudflared` CLI 工具的子进程来创建隧道，命令为 `cloudflared tunnel --url http://localhost:PORT`。解析 `cloudflared` 的输出以获取随机生成的 `*.trycloudflare.com` URL。将此模式设置为 `uvx proxy-local` 的默认行为。",
        "testStrategy": "启动一个本地服务，然后运行 `uvx proxy-local <port>`。验证是否成功创建 Cloudflare 临时隧道，并能通过返回的 URL 访问本地服务。确认访问时没有确认页面。测试端口号错误或 `cloudflared` 未安装时的错误处理。",
        "priority": "high",
        "dependencies": [
          21,
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "集成 Cloudflare Tunnel (持久模式与认证)",
        "description": "为 Cloudflare 提供商添加持久模式支持，包括用户登录、登出、状态检查和使用固定域名的功能。",
        "details": "在 `CloudflareProvider` 中添加 `login`, `logout`, `isAuthenticated` 等方法。`login` 方法将执行 `cloudflared tunnel login` 并引导用户完成浏览器认证流程，并将认证凭据存储在安全位置（如 `~/.cloudflared/`）。`createTunnel` 方法需要根据 `--provider=cloudflare-auth` 或登录状态选择持久模式，并支持 `--cloudflare-custom` 指定域名。需要管理和缓存用户的登录状态。",
        "testStrategy": "执行 `uvx proxy-local --cloudflare-login` 并完成登录流程，验证登录状态是否被正确记录。使用 `--provider=cloudflare-auth` 创建隧道，验证是否使用了固定域名。执行 `uvx proxy-local --cloudflare-logout` 并验证登录状态是否被清除。",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "实现提供商智能选择与回退机制",
        "description": "开发提供商选择逻辑，当默认或指定的提供商失败时，能自动尝试下一个可用的提供商，并能根据 Cloudflare 登录状态推荐模式。",
        "details": "在 `ProviderManager` 中实现一个 `createTunnelWithFallback` 方法。该方法按预定顺序（例如：Cloudflare, Pinggy, Serveo, LocalTunnel）尝试创建隧道。如果一个提供商的 `createTunnel` 方法抛出错误，捕获它并自动尝试列表中的下一个。同时，在选择 Cloudflare 模式时，检查 `isAuthenticated()` 的状态，如果已登录，则向用户推荐使用持久模式。",
        "testStrategy": "模拟 Cloudflare 服务不可用的情况（例如，通过修改 `cloudflared` 命令使其失败），验证程序是否会自动回退到 Pinggy 或其他备选方案。在未登录 Cloudflare 的情况下运行命令，验证是否默认使用临时模式。登录后再次运行，验证是否提示可以使用持久模式。",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "优化控制台输出格式",
        "description": "根据 PRD 中的设计，为不同提供商和模式创建清晰、美观的控制台输出，提升用户体验。",
        "details": "创建一个输出格式化模块。该模块根据当前使用的提供商、模式和隧道结果，生成指定的输出字符串。使用 `chalk` 或类似库为输出添加颜色和图标（如 ✅, 🌐, ⚡）。确保输出内容包括提供商名称、公共 URL、主要特点和关闭隧道的提示。",
        "testStrategy": "分别为 Cloudflare 临时模式、持久模式、Pinggy 和 LocalTunnel 创建隧道，并捕获其控制台输出。将实际输出与 PRD 中定义的模板进行比对，确保所有信息都准确无误地显示。",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "集成 Pinggy 提供商",
        "description": "添加 Pinggy 作为内网穿透的备选方案，它同样无需确认页面，并提供官方 SDK。",
        "details": "创建一个 `PinggyProvider` 类。使用官方的 `@pinggy/pinggy` npm 包来实现 `createTunnel` 方法。根据其 SDK 文档连接服务并获取公共 URL。将其注册到 `ProviderManager` 中。",
        "testStrategy": "运行 `uvx proxy-local 8000 --provider=pinggy`。验证是否成功创建 Pinggy 隧道，并能通过返回的 URL 访问本地服务。测试 SDK 初始化失败或网络连接中断时的错误处理。",
        "priority": "medium",
        "dependencies": [
          21,
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "集成 Serveo 提供商",
        "description": "添加 Serveo.net 作为另一个基于 SSH 的备选穿透方案。",
        "details": "创建一个 `ServeoProvider` 类。通过 Node.js 的 `child_process.spawn` 模块执行 SSH 命令，例如 `ssh -R 80:localhost:<port> serveo.net`。需要解析 SSH 进程的 stdout 来捕获 Serveo 分配的 URL。将其注册到 `ProviderManager`。",
        "testStrategy": "运行 `uvx proxy-local 8000 --provider=serveo`。验证是否成功建立 SSH 隧道，并能通过返回的 URL 访问本地服务。测试本地未安装 SSH 客户端或 Serveo 服务不可用时的错误处理。",
        "priority": "low",
        "dependencies": [
          21,
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "重构 LocalTunnel 提供商",
        "description": "将现有的 LocalTunnel 实现重构，使其符合新的 `TunnelProvider` 接口，作为备选方案保留。",
        "details": "创建一个 `LocalTunnelProvider` 类，将现有的 localtunnel 包的调用逻辑封装在 `createTunnel` 方法中。确保其错误处理和返回格式与新接口保持一致。在 `ProviderManager` 中注册它，并将其优先级设置为较低。",
        "testStrategy": "运行 `uvx proxy-local 8000 --provider=localtunnel`。验证其功能是否与重构前一致，并能正确返回 URL。测试其在回退机制中的表现。",
        "priority": "low",
        "dependencies": [
          21,
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "实现配置文件与环境变量支持",
        "description": "增加对 `.uvxrc` 配置文件和环境变量的支持，允许用户自定义默认提供商和存储 Cloudflare 认证信息。",
        "details": "使用 `cosmiconfig` 或类似库来加载 `.uvxrc` 文件。支持 `UVX_PROVIDER` 环境变量来覆盖默认提供商。配置加载的优先级应为：CLI 参数 > 环境变量 > 配置文件 > 程序默认值。将 Cloudflare 的认证令牌（如果适用）安全地缓存到用户主目录的配置文件中，并从此处读取。",
        "testStrategy": "在项目中创建一个 `.uvxrc` 文件并设置 `defaultProvider: 'pinggy'`，然后运行不带 `--provider` 参数的命令，验证是否使用了 Pinggy。设置环境变量 `UVX_PROVIDER=serveo`，验证其优先级高于配置文件。测试 Cloudflare 登录后，相关认证信息是否被正确写入配置文件。",
        "priority": "medium",
        "dependencies": [
          24,
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "创建 v3.2.0 发布分支",
        "description": "为 v3.2.0 版本创建一个独立的发布分支，以隔离发布活动，确保主开发分支的稳定性。",
        "details": "从最新的 'develop' 或 'main' 分支创建一个名为 'release/v3.2.0' 的新分支。所有与此版本相关的后续步骤，如版本号更新、最终测试和构建，都将在此分支上进行。\n\n伪代码/命令:\n```bash\n# 从 develop 分支创建发布分支\ngit checkout develop\ngit pull origin develop\ngit checkout -b release/v3.2.0\ngit push -u origin release/v3.2.0\n```",
        "testStrategy": "验证 'release/v3.2.0' 分支已成功在远程仓库中创建，并且其初始代码与源分支完全一致。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "更新项目版本号至 v3.2.0",
        "description": "在所有相关的项目文件中（如 package.json, pom.xml, build.gradle 等）将版本号更新为 '3.2.0'。",
        "details": "根据项目的技术栈，找到并修改所有定义版本号的文件。这通常包括包管理配置文件、构建脚本和可能的源代码常量文件。\n\n例如，对于 Node.js 项目:\n```bash\n# 使用 npm version 命令更新 package.json 和 package-lock.json\n# --no-git-tag-version 标志防止 npm 自动创建 git 标签，因为我们将手动进行标记\nnpm version 3.2.0 --no-git-tag-version\n```\n对于 Maven 项目，修改 `pom.xml` 中的 `<version>` 标签。修改后提交到 'release/v3.2.0' 分支。",
        "testStrategy": "运行项目构建命令，并检查生成的构建产物或元数据，确认版本号已正确更新为 '3.2.0'。同时，代码审查确认所有相关文件的版本号都已修改。",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "执行最终的回归和集成测试",
        "description": "在发布分支上对所有功能（包括配置文件支持、优化输出格式、多提供商集成）进行全面的回归和集成测试，确保新版本的稳定性和质量。",
        "details": "执行完整的测试套件，包括单元测试、集成测试和端到端（E2E）测试。特别关注新功能之间的交互以及它们对现有功能的影响。自动化测试流水线应该在 'release/v3.2.0' 分支上触发。\n\n伪代码:\n```bash\n# 安装依赖\nnpm install\n# 运行所有测试\nnpm test\n# 如果有 E2E 测试，也需要运行\nnpm run test:e2e\n```",
        "testStrategy": "确保所有自动化测试用例 100% 通过。对新功能进行手动探索性测试，验证其行为符合预期。检查日志中是否有新的错误或警告。",
        "priority": "high",
        "dependencies": [
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "编写和审查 v3.2.0 发布说明",
        "description": "根据已完成的功能，编写详细的发布说明（Release Notes）或更新日志（CHANGELOG），清晰地列出新功能、错误修复和任何重大变更。",
        "details": "创建一个 `CHANGELOG.md` 文件或更新现有文件，添加 v3.2.0 版本条目。内容应包括：\n- **新功能 (Features):**\n  - 增加了对配置文件的支持。\n  - 优化了输出格式，提升可读性。\n  - 集成了多个新的提供商。\n- **错误修复 (Bug Fixes):**\n  - (列出此版本中修复的关键 bug)\n- **重大变更 (Breaking Changes):**\n  - (列出任何不向后兼容的改动)\n\n发布说明应由产品和开发团队共同审查，确保其准确性和清晰度。",
        "testStrategy": "由至少两名团队成员（一名技术，一名非技术）审查发布说明，确认其内容准确、完整，并且语言清晰易懂。",
        "priority": "medium",
        "dependencies": [
          33
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "构建和打包最终发布产物",
        "description": "在确认所有测试通过后，执行构建流程，生成 v3.2.0 的最终可分发产物，如二进制文件、Docker 镜像或软件包。",
        "details": "使用 CI/CD 流水线或手动执行项目的标准构建命令。确保构建环境是干净的，并且使用的是 'release/v3.2.0' 分支的最新代码。\n\n例如，构建一个 Docker 镜像:\n```bash\n# 使用版本号作为标签\ndocker build -t my-app:3.2.0 -t my-app:latest .\n```\n将生成的产物存档到可信赖的位置，以备发布。",
        "testStrategy": "验证构建过程是否成功完成且无错误。对生成的产物进行基本的功能验证，例如，尝试运行二进制文件或启动 Docker 容器，确保其能正常启动。",
        "priority": "high",
        "dependencies": [
          33,
          34
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "创建并推送 Git 标签",
        "description": "为 v3.2.0 版本的最终提交创建一个带注释的 Git 标签，并将其推送到远程仓库。",
        "details": "在 'release/v3.2.0' 分支的最新 commit 上创建一个名为 'v3.2.0' 的标签。标签信息应简要说明这是 v3.2.0 的正式发布。\n\n伪代码/命令:\n```bash\n# 确保在 release/v3.2.0 分支的最新提交上\ngit checkout release/v3.2.0\ngit pull\n\n# 创建带注释的标签\ngit tag -a v3.2.0 -m \"Release of version 3.2.0\"\n\n# 推送标签到远程仓库\ngit push origin v3.2.0\n```",
        "testStrategy": "在远程 Git 仓库（如 GitHub, GitLab）的标签页面检查 'v3.2.0' 标签是否存在，并确认它指向了正确的提交哈希。",
        "priority": "high",
        "dependencies": [
          35
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "将产物发布到制品库",
        "description": "将 v3.2.0 的构建产物（如 npm 包、Docker 镜像）发布到相应的公共或私有制品库中。",
        "details": "根据产物类型，使用相应的客户端工具进行发布。\n\n例如，发布 npm 包:\n```bash\n# 登录到 npm (如果需要)\nnpm login\n# 发布包\nnpm publish\n```\n\n例如，推送 Docker 镜像:\n```bash\n# 登录到 Docker Hub\ndocker login\n# 推送镜像\ndocker push my-app:3.2.0\ndocker push my-app:latest\n```",
        "testStrategy": "在相应的制品库（如 npmjs.com, hub.docker.com）中搜索并确认 v3.2.0 版本已成功发布。尝试在一个新项目中安装或拉取该版本的包/镜像，验证其可用性。",
        "priority": "high",
        "dependencies": [
          36
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "部署 v3.2.0 到生产环境",
        "description": "将新发布的 v3.2.0 版本部署到生产环境，让最终用户可以使用。",
        "details": "执行生产部署流程。这可能通过自动化的 CI/CD 管道完成，也可能需要手动操作。部署策略可以是蓝绿部署、金丝雀发布或直接滚动更新，以最小化对用户的影响。部署完成后，需要对生产环境进行监控。",
        "testStrategy": "部署完成后，对生产环境进行健康检查和冒烟测试，确保核心功能正常工作。密切监控应用性能指标（APM）、错误率和服务器资源使用情况，观察是否有异常。",
        "priority": "high",
        "dependencies": [
          37
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "合并发布分支并清理",
        "description": "在确认生产环境稳定后，将 'release/v3.2.0' 分支合并回 'main' 和 'develop' 分支，并删除该发布分支。",
        "details": "将发布分支的更改（主要是版本号和 CHANGELOG 的更新）合并回主线分支，以保持同步。\n\n伪代码/命令:\n```bash\n# 合并到 main 分支\ngit checkout main\ngit pull\ngit merge --no-ff release/v3.2.0 -m \"Merge branch 'release/v3.2.0'\"\ngit push\n\n# 合并到 develop 分支\ngit checkout develop\ngit pull\ngit merge --no-ff release/v3.2.0 -m \"Merge branch 'release/v3.2.0'\"\ngit push\n\n# 删除远程和本地的发布分支\ngit push origin --delete release/v3.2.0\ngit branch -d release/v3.2.0\n```",
        "testStrategy": "检查 'main' 和 'develop' 分支的提交历史，确认合并成功。验证版本号和 CHANGELOG 文件已在这些分支中更新。确认 'release/v3.2.0' 分支已被删除。",
        "priority": "medium",
        "dependencies": [
          38
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "发布官方公告",
        "description": "通过官方渠道（如博客、社交媒体、邮件列表）向用户和社区宣布 v3.2.0 版本的发布。",
        "details": "准备一份面向公众的发布公告，重点介绍新版本带来的价值和主要功能更新。公告内容可以基于之前编写的发布说明。在所有相关的社区和平台上发布此公告，并准备好回答用户的问题。",
        "testStrategy": "检查所有指定的渠道，确认公告已成功发布。监控社区反馈和评论，及时响应用户疑问。",
        "priority": "low",
        "dependencies": [
          38
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-05T13:44:42.534Z",
      "updated": "2025-09-06T11:07:28.672Z",
      "description": "Tasks for master context"
    }
  }
}