{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "项目初始化与依赖设置",
        "description": "创建一个新的 Node.js 项目，配置 package.json，并安装构建 CLI 工具所需的核心依赖。",
        "details": "使用 `npm init -y` 初始化项目。安装 `commander` 用于命令行参数解析，以及 `localtunnel` 作为核心的内网穿透服务。在 `package.json` 中设置 `type: 'module'` 以使用 ES模块语法，并配置 `bin` 字段，将 `uvx` 命令指向主执行文件，例如：`\"bin\": { \"uvx\": \"./bin/index.js\" }`。",
        "testStrategy": "运行 `npm install` 确保所有依赖项都已正确安装，并检查 `package.json` 文件是否包含正确的配置。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "初始化 Node.js 项目",
            "description": "创建项目目录并使用 npm 初始化一个新的 Node.js 项目，生成一个默认的 `package.json` 文件。",
            "dependencies": [],
            "details": "在终端中创建一个新的项目文件夹，进入该文件夹，然后运行 `npm init -y` 命令。这将快速生成一个基础的 `package.json` 文件，作为项目配置的起点。",
            "status": "done",
            "testStrategy": "检查项目文件夹中是否已成功生成 `package.json` 文件，并且其内容是有效的 JSON 格式。"
          },
          {
            "id": 2,
            "title": "安装核心依赖项",
            "description": "安装构建 CLI 工具所需的两个核心 npm 包：`commander` 用于解析命令行参数，`localtunnel` 用于实现内网穿透功能。",
            "dependencies": [],
            "details": "在项目根目录下，打开终端并运行命令 `npm install commander localtunnel`。这将把这两个包添加到项目的依赖中。",
            "status": "done",
            "testStrategy": "检查 `package.json` 文件中的 `dependencies` 字段是否已包含 `commander` 和 `localtunnel`。同时确认 `node_modules` 目录已创建且包含这两个包的文件夹。"
          },
          {
            "id": 3,
            "title": "配置 `package.json` 以支持 ES 模块",
            "description": "修改 `package.json` 文件，添加 `type: 'module'` 字段，以便在整个项目中使用现代的 ES 模块语法（`import`/`export`）。",
            "dependencies": [],
            "details": "手动编辑 `package.json` 文件，在文件的顶层（与 `name`, `version` 等字段同级）添加一行 `\"type\": \"module\"`。",
            "status": "done",
            "testStrategy": "创建一个临时的 JS 文件，在其中使用 `import` 语法。尝试用 `node` 命令运行该文件，确认不会因模块系统不匹配而报错。"
          },
          {
            "id": 4,
            "title": "配置 `bin` 字段以定义 CLI 命令",
            "description": "在 `package.json` 中配置 `bin` 字段，将自定义命令 `uvx` 链接到项目的可执行入口文件，使其可以通过 npm 进行全局安装和调用。",
            "dependencies": [],
            "details": "编辑 `package.json` 文件，添加 `bin` 字段，其值为一个对象：`{ \"uvx\": \"./bin/index.js\" }`。这会告诉 npm，当用户安装此包时，需要创建一个名为 `uvx` 的可执行命令。",
            "status": "done",
            "testStrategy": "在项目根目录运行 `npm link`。然后，在终端的任何位置尝试运行 `uvx` 命令。此时预期会报错（因为文件尚未创建），但不应是“命令未找到”的错误。"
          },
          {
            "id": 5,
            "title": "创建入口文件及目录结构",
            "description": "根据 `bin` 字段的配置，创建 `bin` 目录以及主执行文件 `index.js`，并添加 shebang 行使其能够作为脚本直接执行。",
            "dependencies": [],
            "details": "在项目根目录创建一个名为 `bin` 的文件夹。在 `bin` 文件夹内，创建一个名为 `index.js` 的文件。在 `index.js` 文件的第一行添加 `#!/usr/bin/env node`，以指定该文件应由 Node.js 环境执行。",
            "status": "done",
            "testStrategy": "在 `bin/index.js` 文件中添加一行 `console.log('CLI is running!');`。运行 `npm link` 后，在终端执行 `uvx` 命令，验证是否能看到输出 'CLI is running!'。"
          }
        ]
      },
      {
        "id": 2,
        "title": "构建基础 CLI 命令结构",
        "description": "使用 `commander` 库设置 `proxy-local <port>` 命令，并处理用户输入的端口参数。",
        "details": "在主执行文件（例如 `bin/index.js`）中，引入 `commander`。定义一个程序，添加一个名为 `proxy-local` 的命令，它接受一个必需的参数 `<port>`。添加对端口参数的初步验证，确保它是一个有效的数字。伪代码：\n`import { Command } from 'commander';\nconst program = new Command();\nprogram\n  .command('proxy-local <port>')\n  .description('Proxy a local port to a public URL')\n  .action((port) => {\n    console.log(`Port to proxy: ${port}`);\n  });\nprogram.parse(process.argv);`",
        "testStrategy": "在本地运行 `node ./bin/index.js proxy-local 8080`，验证程序是否能正确接收并打印端口号 `8080`。测试无效输入，例如 `uvx proxy-local abc`，并确保程序能给出提示或优雅退出。",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "创建主执行文件并引入 commander",
            "description": "在 `bin` 目录下创建 `index.js` 文件，添加 shebang (`#!/usr/bin/env node`) 以确保其可执行性，并引入 `commander` 库来初始化命令程序实例。",
            "dependencies": [],
            "details": "创建 `bin/index.js` 文件。在文件顶部添加 `#!/usr/bin/env node`。然后，使用 `import { Command } from 'commander';` 引入库，并初始化一个 `Command` 实例：`const program = new Command();`。确保该文件在 `package.json` 的 `bin` 字段中被正确引用。",
            "status": "done",
            "testStrategy": "检查 `bin/index.js` 文件是否存在，并且内容包含 shebang 和 commander 的引入语句。运行 `node ./bin/index.js --version` 不应报错（即使没有定义版本）。"
          },
          {
            "id": 2,
            "title": "定义 `proxy-local <port>` 命令、参数和描述",
            "description": "使用 `program.command()` 方法定义 `proxy-local` 命令，并指定它接受一个名为 `<port>` 的必需参数，同时为其添加清晰的描述信息。",
            "dependencies": [
              "2.1"
            ],
            "details": "在 `program` 实例上链式调用 `.command('proxy-local <port>')` 来定义命令。接着，使用 `.description('Proxy a local port to a public URL')` 为该命令添加用户友好的描述。",
            "status": "done",
            "testStrategy": "运行 `node ./bin/index.js --help`，验证输出中是否包含 `proxy-local <port>` 命令及其描述。"
          },
          {
            "id": 3,
            "title": "实现基础的 action 处理函数",
            "description": "为 `proxy-local` 命令添加一个 `.action()` 处理函数，该函数能够接收用户传入的端口参数，并将其简单地打印到控制台以进行初步验证。",
            "dependencies": [
              "2.2"
            ],
            "details": "在命令定义后链式调用 `.action((port) => { console.log(`Port to proxy: ${port}`); });`。此函数将作为命令执行时的回调，`port` 参数将自动接收用户在命令行中输入的值。",
            "status": "done",
            "testStrategy": "运行 `node ./bin/index.js proxy-local 8080`，检查控制台是否正确输出 `Port to proxy: 8080`。"
          },
          {
            "id": 4,
            "title": "在 action 中添加端口号有效性验证",
            "description": "在 `action` 处理函数内部，增加逻辑来验证用户输入的 `port` 是否为一个有效的数字。如果输入无效，则向用户显示错误信息并终止程序。",
            "dependencies": [
              "2.3"
            ],
            "details": "在 `action` 函数的开头，使用 `const portNumber = parseInt(port, 10);` 将输入转换为数字。然后使用 `if (isNaN(portNumber))` 进行检查。如果验证失败，则通过 `console.error('错误: 端口必须是一个有效的数字。');` 提示用户，并调用 `process.exit(1);` 异常退出。",
            "status": "done",
            "testStrategy": "运行 `node ./bin/index.js proxy-local abc`，验证程序是否打印错误信息并退出。运行 `node ./bin/index.js proxy-local 3000`，验证程序是否正常执行。"
          },
          {
            "id": 5,
            "title": "调用 `program.parse` 使命令生效",
            "description": "在脚本的末尾调用 `program.parse(process.argv)`，这是触发 `commander` 解析命令行参数并执行相应命令和动作的关键步骤。",
            "dependencies": [
              "2.4"
            ],
            "details": "在所有命令定义和配置的最后，添加 `program.parse(process.argv);`。这将启动 `commander` 的解析引擎，使其能够根据用户输入匹配到已定义的 `proxy-local` 命令并执行其 `action`。",
            "status": "done",
            "testStrategy": "确保所有之前的测试用例（如 `proxy-local 8080` 和 `proxy-local abc`）在添加此行代码后仍然按预期工作，证明解析和执行流程已完整建立。"
          }
        ]
      },
      {
        "id": 3,
        "title": "封装内网穿透核心逻辑",
        "description": "创建一个独立的模块，负责调用 `localtunnel` 库来建立从本地端口到公共 URL 的隧道。",
        "details": "创建一个新文件 `src/tunnel.js`。在该文件中，导出一个异步函数 `createTunnel(port)`。此函数将调用 `localtunnel` 包，并返回一个包含公共 URL 的 Promise。示例：\n`import localtunnel from 'localtunnel';\nexport async function createTunnel(port) {\n  const tunnel = await localtunnel({ port });\n  return tunnel.url;\n}`\n需要处理 `localtunnel` 可能抛出的异常。",
        "testStrategy": "编写一个简单的单元测试脚本，调用 `createTunnel` 函数并传入一个有效的、正在运行的本地服务端口，断言它是否返回一个格式正确的 URL 字符串（例如 `https://*.loca.lt`）。",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "创建 `src/tunnel.js` 文件并定义函数骨架",
            "description": "初始化模块文件，并导出一个空的异步函数 `createTunnel(port)`，为后续逻辑实现奠定基础。",
            "dependencies": [],
            "details": "在项目的 `src` 目录下创建一个名为 `tunnel.js` 的新文件。在该文件中，定义并导出一个名为 `createTunnel` 的异步函数，该函数接受一个 `port` 参数。函数体暂时可以为空或只包含一个占位符，例如 `export async function createTunnel(port) {}`。",
            "status": "done",
            "testStrategy": "检查文件 `src/tunnel.js` 是否已创建，并且其中包含 `export async function createTunnel(port)` 的正确函数签名。"
          },
          {
            "id": 2,
            "title": "引入 `localtunnel` 库并实现核心调用",
            "description": "在 `createTunnel` 函数内部，实际调用 `localtunnel` 库来根据用户指定的端口创建隧道。",
            "dependencies": [
              "3.1"
            ],
            "details": "在 `src/tunnel.js` 文件顶部，使用 `import localtunnel from 'localtunnel';` 引入依赖。在 `createTunnel` 函数内部，使用 `const tunnel = await localtunnel({ port });` 来调用库并等待隧道建立。",
            "status": "done",
            "testStrategy": "此步骤的成功将由后续子任务的测试来验证，因为它本身不产生可直接断言的输出。"
          },
          {
            "id": 3,
            "title": "从隧道对象中提取并返回公共 URL",
            "description": "在成功创建隧道后，从 `localtunnel` 返回的对象中获取 `url` 属性，并将其作为函数的返回值。",
            "dependencies": [
              "3.2"
            ],
            "details": "在获取到 `tunnel` 对象后，添加 `return tunnel.url;` 语句，以确保函数返回一个包含公共 URL 的 Promise。",
            "status": "done",
            "testStrategy": "通过一个临时脚本调用该函数，并打印返回值，手动验证其是否为一个有效的 URL 字符串。"
          },
          {
            "id": 4,
            "title": "添加 `try...catch` 块以处理基本异常",
            "description": "为 `localtunnel` 调用添加基础的错误处理机制，以捕获在隧道创建过程中可能发生的异常，防止程序意外崩溃。",
            "dependencies": [
              "3.2"
            ],
            "details": "使用 `try...catch` 结构将 `await localtunnel(...)` 调用包裹起来。在 `catch` 块中，捕获错误对象，并暂时使用 `console.error` 打印错误信息，然后重新抛出异常 `throw error;`，以便上层调用者能够处理它。",
            "status": "done",
            "testStrategy": "尝试传入一个无效的端口号（如 99999）来调用函数，并验证程序是否会捕获异常并打印错误信息，而不是直接崩溃。"
          },
          {
            "id": 5,
            "title": "编写单元测试验证成功路径",
            "description": "根据任务要求，创建一个单元测试脚本，用于验证 `createTunnel` 函数在正常情况下的行为是否符合预期。",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "创建一个测试文件（如 `tunnel.test.js`）。在测试用例中，首先启动一个临时的本地 HTTP 服务器。然后调用 `createTunnel` 函数，并传入该服务器的端口。使用断言来验证返回的 URL 是一个字符串，并且其格式符合 `localtunnel` 的规范（例如，`url.startsWith('https://')`）。测试结束后，确保关闭临时服务器。",
            "status": "done",
            "testStrategy": "运行单元测试套件，并确认此测试用例能够成功通过。"
          }
        ]
      },
      {
        "id": 4,
        "title": "集成 CLI 命令与穿透逻辑",
        "description": "将 `proxy-local` 命令与 `createTunnel` 函数连接起来，当用户执行命令时，实际启动隧道进程。",
        "details": "修改 `bin/index.js` 中的 `action` 处理函数。将其改为 `async` 函数，并在其中调用从 `src/tunnel.js` 导入的 `createTunnel` 函数。使用 `await` 等待隧道建立成功并获取返回的 URL。伪代码：\n`...action(async (port) => {\n  try {\n    const url = await createTunnel(parseInt(port, 10));\n    // 后续步骤将在这里打印 URL\n  } catch (err) {\n    // 后续步骤将在这里处理错误\n  }\n});`",
        "testStrategy": "启动一个本地Web服务器（例如使用 `npx http-server -p 8080`）。然后运行 `node ./bin/index.js proxy-local 8080`。在代码中设置断点或使用 `console.log` 检查是否成功调用了 `createTunnel` 并获取了 URL。",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "在 CLI 文件中导入隧道模块",
            "description": "为了在 `proxy-local` 命令的处理函数中调用隧道创建逻辑，首先需要在 `bin/index.js` 文件中导入 `src/tunnel.js` 模块暴露的 `createTunnel` 函数。",
            "dependencies": [],
            "details": "在 `bin/index.js` 文件的顶部，根据项目配置（ESM 或 CJS），添加 `import { createTunnel } from '../src/tunnel.js';` 或 `const { createTunnel } = require('../src/tunnel.js');`。",
            "status": "done",
            "testStrategy": "确认导入语句没有导致语法错误，并且在后续步骤中 `createTunnel` 变量可以被正确引用。"
          },
          {
            "id": 2,
            "title": "将 `action` 处理函数转换为异步函数",
            "description": "由于 `createTunnel` 是一个返回 Promise 的异步函数，为了能够使用 `await` 语法来等待其结果，必须将 `commander` 命令的 `action` 回调函数声明为 `async`。",
            "dependencies": [],
            "details": "找到 `program.command('proxy-local <port>').action(...)` 这行代码，将其回调函数从 `(port) => { ... }` 修改为 `async (port) => { ... }`。",
            "status": "done",
            "testStrategy": "修改后运行 CLI 命令，确保 `commander` 能够正确执行异步的 `action` 函数而不会报错。"
          },
          {
            "id": 3,
            "title": "在 `action` 函数中调用 `createTunnel`",
            "description": "在异步的 `action` 函数内部，调用已导入的 `createTunnel` 函数，并将从命令行获取的端口号作为参数传递给它。",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "在 `action` 函数体内部，添加调用代码。由于命令行的参数是字符串类型，需要使用 `parseInt(port, 10)` 将其转换为数字。示例：`const url = await createTunnel(parseInt(port, 10));`。",
            "status": "done",
            "testStrategy": "在 `createTunnel` 函数内部设置一个 `console.log` 或断点，运行命令 `node ./bin/index.js proxy-local 8080`，验证该函数是否被成功调用，并且接收到的 `port` 参数是否为数字 `8080`。"
          },
          {
            "id": 4,
            "title": "实现基础的 `try...catch` 错误处理结构",
            "description": "为 `createTunnel` 的调用添加 `try...catch` 块，以捕获可能发生的异常（如网络错误、服务不可用等），防止程序因未处理的 Promise rejection 而崩溃。",
            "dependencies": [
              "4.3"
            ],
            "details": "将 `await createTunnel(...)` 调用语句包裹在 `try` 块中。在 `catch (err)` 块中，暂时添加一个简单的错误日志输出，例如 `console.error('创建隧道失败:', err.message);` 和 `process.exit(1);`。",
            "status": "done",
            "testStrategy": "通过模拟一个错误场景（例如断开网络连接）来运行命令，验证程序是否能够进入 `catch` 块，打印错误信息并正常退出，而不是崩溃。"
          },
          {
            "id": 5,
            "title": "处理成功情况并向用户显示 URL",
            "description": "当 `createTunnel` 成功返回 URL 后，需要将这个公开可访问的 URL 打印到控制台，明确告知用户隧道已经建立成功。",
            "dependencies": [
              "4.3",
              "4.4"
            ],
            "details": "在 `try` 块中，紧跟在 `await createTunnel(...)` 语句之后，添加 `console.log` 语句来显示获取到的 `url`。可以使用一些友好的提示语，例如 `console.log(`隧道已就绪！公网访问地址: ${url}`);`。",
            "status": "done",
            "testStrategy": "启动一个本地 Web 服务器（如 `npx http-server -p 8080`），然后运行 `node ./bin/index.js proxy-local 8080`。验证控制台是否成功打印出格式正确的 `localtunnel` URL。"
          }
        ]
      },
      {
        "id": 5,
        "title": "实现用户友好的输出",
        "description": "在成功创建隧道后，向用户清晰地显示代理的公共 URL。",
        "details": "安装 `chalk` 库 (`npm install chalk`) 以美化控制台输出。在获取到隧道 URL 后，使用 `console.log` 格式化输出，用醒目的颜色高亮显示 URL。例如：\n`console.log(`\\n✅ Proxy successful!`);\nconsole.log(`Local:  http://localhost:${port}`);\nconsole.log(`Public: ${chalk.green(url)}`);`",
        "testStrategy": "运行 `uvx proxy-local 8080` 命令，并目视检查控制台输出是否清晰、美观，并且公共 URL 是否以高亮颜色显示。",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "增加全面的错误处理",
        "description": "为各种潜在的失败情况添加健壮的错误处理机制，例如端口无效、端口被占用或 `localtunnel` 服务不可用。",
        "details": "在调用 `createTunnel` 的地方使用 `try...catch` 块。在 `catch` 块中，检查错误的类型或消息，并向用户提供有意义的反馈。例如，如果端口无效，提示“端口必须是数字”。如果 `localtunnel` 连接失败，提示“无法连接到穿透服务，请检查网络连接”。可以使用 `chalk.red` 来显示错误消息。",
        "testStrategy": "模拟各种错误场景进行测试：1. 提供一个非数字端口 `uvx proxy-local test`。2. 提供一个未被监听的端口。3. 在断网环境下运行命令。验证每种情况下程序是否都能捕获错误并显示正确的错误信息，而不是崩溃。",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "配置可执行文件和本地测试",
        "description": "确保项目可以作为全局命令正确安装和执行。",
        "details": "在主执行文件 `bin/index.js` 的顶部添加 shebang 行 `#!/usr/bin/env node`。在项目根目录运行 `npm link`，这将创建一个符号链接，允许你在系统的任何地方通过输入 `uvx` 来测试你的 CLI 工具，而无需发布到 npm。",
        "testStrategy": "运行 `npm link` 后，打开一个新的终端窗口，执行 `uvx proxy-local 3000`。验证命令是否能被识别并成功执行，其行为应与 `node ./bin/index.js proxy-local 3000` 完全一致。",
        "priority": "medium",
        "dependencies": [
          1,
          5,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "处理隧道关闭事件",
        "description": "监听 `localtunnel` 的关闭事件，并在隧道意外关闭时通知用户。",
        "details": "修改 `createTunnel` 函数，使其不仅返回 URL，还返回 `tunnel` 对象本身。在主逻辑中，监听 `tunnel.on('close', ...)` 事件。当隧道关闭时，向用户打印一条消息，例如 `console.log('Tunnel closed.')`。同时，优雅地退出进程 `process.exit()`。",
        "testStrategy": "运行工具并建立隧道后，手动访问 `localtunnel` 提供的 URL。某些情况下（如长时间不活动），隧道可能会自动关闭。观察控制台是否打印了关闭信息并正常退出。",
        "priority": "low",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "编写项目文档 (README.md)",
        "description": "创建一个 `README.md` 文件，清晰地说明工具的用途、如何安装以及如何使用。",
        "details": "在项目根目录创建 `README.md` 文件。内容应包括：\n- **项目标题和简介**: 介绍 `uvx` 是一个什么工具。\n- **安装**: `npm install -g <your-package-name>`\n- **使用方法**: 提供清晰的命令示例，`uvx proxy-local 8080`，并解释其作用。\n- **选项**: 如果未来添加了其他选项，也在此处说明。",
        "testStrategy": "让一个不了解该项目的同事或朋友阅读 README，看他们是否能根据文档成功理解、安装和使用该工具。",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "准备发布到 NPM",
        "description": "最终确定 `package.json` 中的所有字段，并准备将该工具作为公共包发布到 npm。",
        "details": "检查并完善 `package.json`：设置一个唯一的 `name`，更新 `version`，填写 `description`、`author`、`license` 和 `keywords` 字段。确保 `main` 和 `files` 字段正确配置，只包含必要的文件（如 `bin`, `src`）。登录 npm (`npm login`) 并运行 `npm publish --access public` 进行发布。",
        "testStrategy": "在发布前，运行 `npm pack` 生成一个 `.tgz` 压缩包。在一个新的空目录中，运行 `npm install ../path/to/your.tgz` 来模拟从 npm 安装。然后测试已安装的命令是否正常工作，以确保打包内容完整且正确。",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "架构设计与提供商抽象层",
        "description": "根据PRD要求，建立一个灵活的提供商管理架构。定义统一的 `TunnelProvider` 接口，并创建一个提供商管理器，用于注册、选择和切换不同的内网穿透服务。",
        "details": "创建 `src/providers/interface.ts` 文件来定义 `TunnelProvider` 接口，应包含 `name`, `createTunnel`, `isAvailable`, `getFeatures` 等方法。然后创建 `src/providers/manager.ts`，实现一个 `ProviderManager` 类，该类维护一个提供商列表，并包含 `selectProvider` 和 `getNextProvider` 等核心逻辑。这是后续所有提供商集成的基础。",
        "testStrategy": "为 `ProviderManager` 编写单元测试，模拟注册和选择提供商的场景，确保其逻辑正确。验证接口定义是否满足所有已知和未来提供商的需求。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "集成 Pinggy 提供商 (P0)",
        "description": "作为最高优先级的任务，集成 Pinggy 作为默认的内网穿透服务，以解决 localtunnel 首次访问需要确认的核心痛点。",
        "details": "安装官方SDK: `npm install @pinggy/pinggy`。在 `src/providers/pinggy.ts` 中实现 `TunnelProvider` 接口。使用 `@pinggy/pinggy` 的 `connect` 方法来创建隧道。需要处理其返回的 URL 和可能发生的连接错误。确保正确捕获并返回 `TunnelResult` 对象。",
        "testStrategy": "编写集成测试，启动一个本地服务，然后调用 Pinggy 提供商的 `createTunnel` 方法，验证是否能成功获取公网 URL，并通过该 URL 访问到本地服务。测试连接失败时的错误处理。",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "优化 CLI 命令接口",
        "description": "更新 `uvx proxy-local` 命令，以支持多提供商选择、列出可用提供商等新功能。",
        "details": "使用 `commander` 库（最新版本）来重构 CLI 参数解析。添加 `--provider <name>` 选项来指定服务商，以及 `--list-providers` 标志来打印所有已注册提供商及其特点。默认行为（不带参数）应触发提供商管理器的默认选择逻辑。示例代码：`program.command('proxy-local <port>').option('-p, --provider <name>', 'Specify a tunnel provider').option('--list-providers', 'List all available providers').action(...)`",
        "testStrategy": "通过命令行手动测试：`uvx proxy-local 8000`, `uvx proxy-local 8000 --provider=pinggy`, `uvx proxy-local --list-providers`。编写自动化脚本来验证不同参数组合下的行为是否符合预期。",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "实现智能回退与提供商选择逻辑",
        "description": "在提供商管理器中实现核心的智能回退功能。当首选提供商失败时，系统应能自动、无缝地尝试下一个可用的提供商。",
        "details": "在 `ProviderManager` 中实现一个 `createTunnelWithFallback` 方法。该方法内部维护一个按优先级排序的提供商列表（例如 `[Pinggy, Serveo, LocalTunnel]`)。它会按顺序尝试调用每个提供商的 `createTunnel` 方法，一旦成功则立即返回结果。如果一个提供商失败，它会捕获错误，记录日志，并继续尝试下一个，直到所有提供商都失败为止。",
        "testStrategy": "编写单元测试，模拟提供商成功和失败的场景。例如，创建一个 mock 的 Pinggy 提供商使其总是抛出错误，验证系统是否会自动尝试下一个（如 Serveo）。集成测试：通过断开网络或使用无效端口来触发真实的回退场景。",
        "priority": "high",
        "dependencies": [
          12,
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "集成 Serveo 提供商",
        "description": "集成 Serveo.net 作为另一个无确认页面的备选方案，通过 SSH 隧道实现。",
        "details": "在 `src/providers/serveo.ts` 中实现 `TunnelProvider` 接口。使用 Node.js 的 `child_process.spawn` 模块来执行 SSH 命令：`ssh -R 80:localhost:<port> serveo.net`。需要监听子进程的 `stdout` 来捕获 Serveo 分配的公网 URL，并监听 `stderr` 和 `exit` 事件来处理错误。由于需要解析输出，正则表达式可能是个好方法，例如 `/Forwarding HTTP traffic from (https:\\[^\\]+)/`。",
        "testStrategy": "集成测试：启动本地服务，调用 Serveo 提供商的 `createTunnel`，验证是否能正确解析出 URL 并成功建立连接。测试当 SSH 命令失败（例如 `ssh` 未安装）或连接被拒绝时的错误处理。",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "保留并重构 LocalTunnel 提供商",
        "description": "将现有的 LocalTunnel 功能重构，使其符合新的 `TunnelProvider` 接口，作为备选方案保留。",
        "details": "安装 `localtunnel` npm 包。在 `src/providers/localtunnel.ts` 中实现 `TunnelProvider` 接口。调用 `localtunnel({ port })` 并处理其返回的 promise。将获取到的 `tunnel.url` 包装在 `TunnelResult` 对象中返回。处理 `localtunnel` 可能抛出的各种异常。",
        "testStrategy": "集成测试：确保在新的架构下，`uvx proxy-local 8000 --provider=localtunnel` 命令能像以前一样正常工作。验证其创建的隧道 URL 确实需要点击确认页面。",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "实现配置管理功能",
        "description": "支持通过配置文件和环境变量来设置默认提供商，以满足高级用户的定制需求。",
        "details": "引入 `cosmiconfig` 库 (`npm install cosmiconfig`) 来统一处理配置。在 `ProviderManager` 初始化时，使用 `cosmiconfig` 搜索 `.uvxrc` 文件或 `uvx` 在 `package.json` 中的字段。同时，检查 `UVX_PROVIDER` 环境变量。配置加载的优先级应为：CLI 参数 > 环境变量 > 配置文件 > 程序默认值。",
        "testStrategy": "创建不同的配置文件（如 `.uvxrc`）和设置环境变量，然后运行命令，验证提供商的选择顺序是否遵循预设的优先级规则。例如，当配置文件设置为 `serveo`，环境变量设置为 `localtunnel` 时，默认应使用 `localtunnel`。",
        "priority": "medium",
        "dependencies": [
          13,
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "优化输出格式与用户体验",
        "description": "根据 PRD 的要求，美化命令行输出，为用户提供更清晰、更有用的信息，如当前提供商、URL、特点等。",
        "details": "创建一个专门的 UI/Logger 模块。在隧道创建成功后，调用此模块来打印格式化的成功信息。可以使用 `chalk` 库来添加颜色，使输出更具可读性。输出内容应动态生成，包含提供商名称、公共 URL、特点（如“无确认页面”）、速度评估和 HTTPS 支持情况。",
        "testStrategy": "手动运行命令并截图，与 PRD 中的输出示例进行比对，确保格式、颜色和信息完全一致。编写快照测试（Snapshot Testing）来锁定输出格式，防止未来被意外修改。",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "完善全局错误处理和重试机制",
        "description": "为所有提供商和核心流程添加健壮的错误处理机制，当隧道创建失败时，向用户显示友好的错误信息和排错建议。",
        "details": "在 `ProviderManager` 的回退逻辑中，对每个提供商的 `createTunnel` 调用都使用 `try...catch` 块。当捕获到错误时，不仅要尝试下一个提供商，还要记录详细的错误信息。如果所有提供商都失败了，应向用户显示一个总结性的错误报告，例如：“所有内网穿透服务商（Pinggy, Serveo, LocalTunnel）均尝试失败。请检查您的网络连接或目标端口 `8000` 是否已启动。”",
        "testStrategy": "单元测试：模拟各种错误情况，如网络断开、端口被占用、提供商服务器宕机等，验证错误信息是否友好且准确。手动测试：故意使用一个未启动的端口号运行命令，检查最终的错误输出是否符合预期。",
        "priority": "medium",
        "dependencies": [
          14,
          15,
          16
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "为未来扩展提供商预留接口",
        "description": "确保当前架构具有良好的可扩展性，方便未来快速添加如 Bore、Staqlab 等新的提供商。",
        "details": "编写一份开发者文档（例如 `CONTRIBUTING.md`），详细说明如何实现一个新的 `TunnelProvider` 接口并将其注册到 `ProviderManager` 中。在代码中为 `ProviderManager` 的提供商列表添加注释，说明如何添加新项。可以创建一个 `src/providers/template.ts` 文件作为新提供商的实现模板。",
        "testStrategy": "代码审查（Code Review）：邀请另一位开发者根据文档尝试添加一个“假的”提供商（mock provider），看流程是否顺畅，文档是否清晰。确保添加新提供商不需要修改管理器核心代码，只需创建新文件并注册即可。",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "架构设计与提供商抽象",
        "description": "创建内网穿透服务的核心抽象层，包括定义统一的 `TunnelProvider` 接口和提供商管理器，为支持多种服务商奠定基础。",
        "details": "定义一个 `TunnelProvider` TypeScript 接口，包含 `name`, `createTunnel`, `isAvailable`, `getFeatures` 等方法。创建一个 `ProviderManager` 类，负责注册、获取和管理所有可用的提供商实现。此设计将解耦核心逻辑与具体提供商的实现。伪代码：\n```typescript\ninterface TunnelProvider {\n  name: string;\n  createTunnel(port: number, options?: any): Promise<{ url: string }>;\n  isAvailable(): Promise<boolean>;\n}\n\nclass ProviderManager {\n  private providers: Map<string, TunnelProvider> = new Map();\n  register(provider: TunnelProvider) { this.providers.set(provider.name, provider); }\n  get(name: string): TunnelProvider | undefined { return this.providers.get(name); }\n  getDefault(): TunnelProvider { /* ... */ }\n}\n```",
        "testStrategy": "单元测试 `ProviderManager` 的注册和获取功能。验证 `TunnelProvider` 接口定义的完整性。模拟不同的提供商实现并进行注册测试。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "CLI 命令结构重构",
        "description": "更新 `uvx proxy-local` 命令以支持新的多提供商参数，如 `--provider`, `--list-providers` 和 Cloudflare 特定选项。",
        "details": "使用 `commander` 或 `yargs` 等库来重构 CLI 参数解析逻辑。添加 `--provider` 选项，接受 `cloudflare`, `pinggy` 等值。添加 `--list-providers` 标志，用于列出所有已注册的提供商。为 Cloudflare 添加 `--cloudflare-login`, `--cloudflare-logout`, `--cloudflare-custom` 等专用命令。确保旧命令 `uvx proxy-local 8000` 能平滑过渡到默认使用 Cloudflare。",
        "testStrategy": "单元测试 CLI 参数解析。运行命令 `uvx proxy-local 8000 --provider=cloudflare` 并验证解析出的选项是否正确。测试 `uvx proxy-local --list-providers` 是否能触发正确的处理函数。测试无效提供商名称的错误处理。",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "集成 Cloudflare Tunnel (临时模式)",
        "description": "实现 Cloudflare Tunnel 作为默认提供商，重点是无需登录的临时模式，解决核心的用户体验问题。",
        "details": "创建一个 `CloudflareProvider` 类实现 `TunnelProvider` 接口。使用 `cloudflared` CLI 工具的子进程来创建隧道，命令为 `cloudflared tunnel --url http://localhost:PORT`。解析 `cloudflared` 的输出以获取随机生成的 `*.trycloudflare.com` URL。将此模式设置为 `uvx proxy-local` 的默认行为。",
        "testStrategy": "启动一个本地服务，然后运行 `uvx proxy-local <port>`。验证是否成功创建 Cloudflare 临时隧道，并能通过返回的 URL 访问本地服务。确认访问时没有确认页面。测试端口号错误或 `cloudflared` 未安装时的错误处理。",
        "priority": "high",
        "dependencies": [
          21,
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "集成 Cloudflare Tunnel (持久模式与认证)",
        "description": "为 Cloudflare 提供商添加持久模式支持，包括用户登录、登出、状态检查和使用固定域名的功能。",
        "details": "在 `CloudflareProvider` 中添加 `login`, `logout`, `isAuthenticated` 等方法。`login` 方法将执行 `cloudflared tunnel login` 并引导用户完成浏览器认证流程，并将认证凭据存储在安全位置（如 `~/.cloudflared/`）。`createTunnel` 方法需要根据 `--provider=cloudflare-auth` 或登录状态选择持久模式，并支持 `--cloudflare-custom` 指定域名。需要管理和缓存用户的登录状态。",
        "testStrategy": "执行 `uvx proxy-local --cloudflare-login` 并完成登录流程，验证登录状态是否被正确记录。使用 `--provider=cloudflare-auth` 创建隧道，验证是否使用了固定域名。执行 `uvx proxy-local --cloudflare-logout` 并验证登录状态是否被清除。",
        "priority": "high",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "实现提供商智能选择与回退机制",
        "description": "开发提供商选择逻辑，当默认或指定的提供商失败时，能自动尝试下一个可用的提供商，并能根据 Cloudflare 登录状态推荐模式。",
        "details": "在 `ProviderManager` 中实现一个 `createTunnelWithFallback` 方法。该方法按预定顺序（例如：Cloudflare, Pinggy, Serveo, LocalTunnel）尝试创建隧道。如果一个提供商的 `createTunnel` 方法抛出错误，捕获它并自动尝试列表中的下一个。同时，在选择 Cloudflare 模式时，检查 `isAuthenticated()` 的状态，如果已登录，则向用户推荐使用持久模式。",
        "testStrategy": "模拟 Cloudflare 服务不可用的情况（例如，通过修改 `cloudflared` 命令使其失败），验证程序是否会自动回退到 Pinggy 或其他备选方案。在未登录 Cloudflare 的情况下运行命令，验证是否默认使用临时模式。登录后再次运行，验证是否提示可以使用持久模式。",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "优化控制台输出格式",
        "description": "根据 PRD 中的设计，为不同提供商和模式创建清晰、美观的控制台输出，提升用户体验。",
        "details": "创建一个输出格式化模块。该模块根据当前使用的提供商、模式和隧道结果，生成指定的输出字符串。使用 `chalk` 或类似库为输出添加颜色和图标（如 ✅, 🌐, ⚡）。确保输出内容包括提供商名称、公共 URL、主要特点和关闭隧道的提示。",
        "testStrategy": "分别为 Cloudflare 临时模式、持久模式、Pinggy 和 LocalTunnel 创建隧道，并捕获其控制台输出。将实际输出与 PRD 中定义的模板进行比对，确保所有信息都准确无误地显示。",
        "priority": "medium",
        "dependencies": [
          23
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "集成 Pinggy 提供商",
        "description": "添加 Pinggy 作为内网穿透的备选方案，它同样无需确认页面，并提供官方 SDK。",
        "details": "创建一个 `PinggyProvider` 类。使用官方的 `@pinggy/pinggy` npm 包来实现 `createTunnel` 方法。根据其 SDK 文档连接服务并获取公共 URL。将其注册到 `ProviderManager` 中。",
        "testStrategy": "运行 `uvx proxy-local 8000 --provider=pinggy`。验证是否成功创建 Pinggy 隧道，并能通过返回的 URL 访问本地服务。测试 SDK 初始化失败或网络连接中断时的错误处理。",
        "priority": "medium",
        "dependencies": [
          21,
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "集成 Serveo 提供商",
        "description": "添加 Serveo.net 作为另一个基于 SSH 的备选穿透方案。",
        "details": "创建一个 `ServeoProvider` 类。通过 Node.js 的 `child_process.spawn` 模块执行 SSH 命令，例如 `ssh -R 80:localhost:<port> serveo.net`。需要解析 SSH 进程的 stdout 来捕获 Serveo 分配的 URL。将其注册到 `ProviderManager`。",
        "testStrategy": "运行 `uvx proxy-local 8000 --provider=serveo`。验证是否成功建立 SSH 隧道，并能通过返回的 URL 访问本地服务。测试本地未安装 SSH 客户端或 Serveo 服务不可用时的错误处理。",
        "priority": "low",
        "dependencies": [
          21,
          22
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "重构 LocalTunnel 提供商",
        "description": "将现有的 LocalTunnel 实现重构，使其符合新的 `TunnelProvider` 接口，作为备选方案保留。",
        "details": "创建一个 `LocalTunnelProvider` 类，将现有的 localtunnel 包的调用逻辑封装在 `createTunnel` 方法中。确保其错误处理和返回格式与新接口保持一致。在 `ProviderManager` 中注册它，并将其优先级设置为较低。",
        "testStrategy": "运行 `uvx proxy-local 8000 --provider=localtunnel`。验证其功能是否与重构前一致，并能正确返回 URL。测试其在回退机制中的表现。",
        "priority": "low",
        "dependencies": [
          21,
          22
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "实现配置文件与环境变量支持",
        "description": "增加对 `.uvxrc` 配置文件和环境变量的支持，允许用户自定义默认提供商和存储 Cloudflare 认证信息。",
        "details": "使用 `cosmiconfig` 或类似库来加载 `.uvxrc` 文件。支持 `UVX_PROVIDER` 环境变量来覆盖默认提供商。配置加载的优先级应为：CLI 参数 > 环境变量 > 配置文件 > 程序默认值。将 Cloudflare 的认证令牌（如果适用）安全地缓存到用户主目录的配置文件中，并从此处读取。",
        "testStrategy": "在项目中创建一个 `.uvxrc` 文件并设置 `defaultProvider: 'pinggy'`，然后运行不带 `--provider` 参数的命令，验证是否使用了 Pinggy。设置环境变量 `UVX_PROVIDER=serveo`，验证其优先级高于配置文件。测试 Cloudflare 登录后，相关认证信息是否被正确写入配置文件。",
        "priority": "medium",
        "dependencies": [
          24,
          25
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "创建 v3.2.0 发布分支",
        "description": "为 v3.2.0 版本创建一个独立的发布分支，以隔离发布活动，确保主开发分支的稳定性。",
        "details": "从最新的 'develop' 或 'main' 分支创建一个名为 'release/v3.2.0' 的新分支。所有与此版本相关的后续步骤，如版本号更新、最终测试和构建，都将在此分支上进行。\n\n伪代码/命令:\n```bash\n# 从 develop 分支创建发布分支\ngit checkout develop\ngit pull origin develop\ngit checkout -b release/v3.2.0\ngit push -u origin release/v3.2.0\n```",
        "testStrategy": "验证 'release/v3.2.0' 分支已成功在远程仓库中创建，并且其初始代码与源分支完全一致。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "更新项目版本号至 v3.2.0",
        "description": "在所有相关的项目文件中（如 package.json, pom.xml, build.gradle 等）将版本号更新为 '3.2.0'。",
        "details": "根据项目的技术栈，找到并修改所有定义版本号的文件。这通常包括包管理配置文件、构建脚本和可能的源代码常量文件。\n\n例如，对于 Node.js 项目:\n```bash\n# 使用 npm version 命令更新 package.json 和 package-lock.json\n# --no-git-tag-version 标志防止 npm 自动创建 git 标签，因为我们将手动进行标记\nnpm version 3.2.0 --no-git-tag-version\n```\n对于 Maven 项目，修改 `pom.xml` 中的 `<version>` 标签。修改后提交到 'release/v3.2.0' 分支。",
        "testStrategy": "运行项目构建命令，并检查生成的构建产物或元数据，确认版本号已正确更新为 '3.2.0'。同时，代码审查确认所有相关文件的版本号都已修改。",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "执行最终的回归和集成测试",
        "description": "在发布分支上对所有功能（包括配置文件支持、优化输出格式、多提供商集成）进行全面的回归和集成测试，确保新版本的稳定性和质量。",
        "details": "执行完整的测试套件，包括单元测试、集成测试和端到端（E2E）测试。特别关注新功能之间的交互以及它们对现有功能的影响。自动化测试流水线应该在 'release/v3.2.0' 分支上触发。\n\n伪代码:\n```bash\n# 安装依赖\nnpm install\n# 运行所有测试\nnpm test\n# 如果有 E2E 测试，也需要运行\nnpm run test:e2e\n```",
        "testStrategy": "确保所有自动化测试用例 100% 通过。对新功能进行手动探索性测试，验证其行为符合预期。检查日志中是否有新的错误或警告。",
        "priority": "high",
        "dependencies": [
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "编写和审查 v3.2.0 发布说明",
        "description": "根据已完成的功能，编写详细的发布说明（Release Notes）或更新日志（CHANGELOG），清晰地列出新功能、错误修复和任何重大变更。",
        "details": "创建一个 `CHANGELOG.md` 文件或更新现有文件，添加 v3.2.0 版本条目。内容应包括：\n- **新功能 (Features):**\n  - 增加了对配置文件的支持。\n  - 优化了输出格式，提升可读性。\n  - 集成了多个新的提供商。\n- **错误修复 (Bug Fixes):**\n  - (列出此版本中修复的关键 bug)\n- **重大变更 (Breaking Changes):**\n  - (列出任何不向后兼容的改动)\n\n发布说明应由产品和开发团队共同审查，确保其准确性和清晰度。",
        "testStrategy": "由至少两名团队成员（一名技术，一名非技术）审查发布说明，确认其内容准确、完整，并且语言清晰易懂。",
        "priority": "medium",
        "dependencies": [
          33
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "构建和打包最终发布产物",
        "description": "在确认所有测试通过后，执行构建流程，生成 v3.2.0 的最终可分发产物，如二进制文件、Docker 镜像或软件包。",
        "details": "使用 CI/CD 流水线或手动执行项目的标准构建命令。确保构建环境是干净的，并且使用的是 'release/v3.2.0' 分支的最新代码。\n\n例如，构建一个 Docker 镜像:\n```bash\n# 使用版本号作为标签\ndocker build -t my-app:3.2.0 -t my-app:latest .\n```\n将生成的产物存档到可信赖的位置，以备发布。",
        "testStrategy": "验证构建过程是否成功完成且无错误。对生成的产物进行基本的功能验证，例如，尝试运行二进制文件或启动 Docker 容器，确保其能正常启动。",
        "priority": "high",
        "dependencies": [
          33,
          34
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "创建并推送 Git 标签",
        "description": "为 v3.2.0 版本的最终提交创建一个带注释的 Git 标签，并将其推送到远程仓库。",
        "details": "在 'release/v3.2.0' 分支的最新 commit 上创建一个名为 'v3.2.0' 的标签。标签信息应简要说明这是 v3.2.0 的正式发布。\n\n伪代码/命令:\n```bash\n# 确保在 release/v3.2.0 分支的最新提交上\ngit checkout release/v3.2.0\ngit pull\n\n# 创建带注释的标签\ngit tag -a v3.2.0 -m \"Release of version 3.2.0\"\n\n# 推送标签到远程仓库\ngit push origin v3.2.0\n```",
        "testStrategy": "在远程 Git 仓库（如 GitHub, GitLab）的标签页面检查 'v3.2.0' 标签是否存在，并确认它指向了正确的提交哈希。",
        "priority": "high",
        "dependencies": [
          35
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "将产物发布到制品库",
        "description": "将 v3.2.0 的构建产物（如 npm 包、Docker 镜像）发布到相应的公共或私有制品库中。",
        "details": "根据产物类型，使用相应的客户端工具进行发布。\n\n例如，发布 npm 包:\n```bash\n# 登录到 npm (如果需要)\nnpm login\n# 发布包\nnpm publish\n```\n\n例如，推送 Docker 镜像:\n```bash\n# 登录到 Docker Hub\ndocker login\n# 推送镜像\ndocker push my-app:3.2.0\ndocker push my-app:latest\n```",
        "testStrategy": "在相应的制品库（如 npmjs.com, hub.docker.com）中搜索并确认 v3.2.0 版本已成功发布。尝试在一个新项目中安装或拉取该版本的包/镜像，验证其可用性。",
        "priority": "high",
        "dependencies": [
          36
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "部署 v3.2.0 到生产环境",
        "description": "将新发布的 v3.2.0 版本部署到生产环境，让最终用户可以使用。",
        "details": "执行生产部署流程。这可能通过自动化的 CI/CD 管道完成，也可能需要手动操作。部署策略可以是蓝绿部署、金丝雀发布或直接滚动更新，以最小化对用户的影响。部署完成后，需要对生产环境进行监控。",
        "testStrategy": "部署完成后，对生产环境进行健康检查和冒烟测试，确保核心功能正常工作。密切监控应用性能指标（APM）、错误率和服务器资源使用情况，观察是否有异常。",
        "priority": "high",
        "dependencies": [
          37
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "合并发布分支并清理",
        "description": "在确认生产环境稳定后，将 'release/v3.2.0' 分支合并回 'main' 和 'develop' 分支，并删除该发布分支。",
        "details": "将发布分支的更改（主要是版本号和 CHANGELOG 的更新）合并回主线分支，以保持同步。\n\n伪代码/命令:\n```bash\n# 合并到 main 分支\ngit checkout main\ngit pull\ngit merge --no-ff release/v3.2.0 -m \"Merge branch 'release/v3.2.0'\"\ngit push\n\n# 合并到 develop 分支\ngit checkout develop\ngit pull\ngit merge --no-ff release/v3.2.0 -m \"Merge branch 'release/v3.2.0'\"\ngit push\n\n# 删除远程和本地的发布分支\ngit push origin --delete release/v3.2.0\ngit branch -d release/v3.2.0\n```",
        "testStrategy": "检查 'main' 和 'develop' 分支的提交历史，确认合并成功。验证版本号和 CHANGELOG 文件已在这些分支中更新。确认 'release/v3.2.0' 分支已被删除。",
        "priority": "medium",
        "dependencies": [
          38
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "发布官方公告",
        "description": "通过官方渠道（如博客、社交媒体、邮件列表）向用户和社区宣布 v3.2.0 版本的发布。",
        "details": "准备一份面向公众的发布公告，重点介绍新版本带来的价值和主要功能更新。公告内容可以基于之前编写的发布说明。在所有相关的社区和平台上发布此公告，并准备好回答用户的问题。",
        "testStrategy": "检查所有指定的渠道，确认公告已成功发布。监控社区反馈和评论，及时响应用户疑问。",
        "priority": "low",
        "dependencies": [
          38
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "实现 Cloudflare 域名选择和管理功能",
        "description": "引入一个交互式界面，用于自动安装 `cloudflared`、选择和管理 Cloudflare 域名，支持随机域名、自定义 A 记录域名，并提供域名固定功能以提升用户体验。",
        "status": "done",
        "dependencies": [
          23,
          24
        ],
        "priority": "medium",
        "details": "此任务旨在通过一个统一的交互式流程简化 Cloudflare 隧道域名的配置。1. **`cloudflared` 自动检测与安装**：在执行命令时，首先检查系统中 `cloudflared` 是否存在且在 PATH 中。如果未找到，则根据用户的操作系统（macOS/Linux/Windows）提示用户并自动执行安装命令（例如，在 macOS 上使用 `brew install cloudflared`）。2. **交互式域名选择界面**：使用 `inquirer.js` 或类似库构建一个命令行菜单。当用户未指定域名时，此菜单将自动触发，提供以下选项：a) 使用随机域名（`*.trycloudflare.com` 的临时隧道）；b) 从已登录的 Cloudflare 账户中选择一个已配置的 A 记录域名（需要认证）；c) 手动输入一个自定义域名（需指向 Cloudflare DNS）。3. **Cloudflare 账户集成**：当用户选择从账户中选择域名时，系统将检查当前的认证状态（复用任务24的功能）。如果用户未登录，将引导用户完成 `cloudflared tunnel login` 流程。登录后，通过 Cloudflare API 获取用户账户下的可用域名列表，并筛选出包含 A 记录的域名进行展示。4. **域名固定功能**：用户通过交互界面选择一个域名后，系统将询问是否将其“固定”为默认域名。如果用户同意，该域名将被保存在本地配置文件中（例如 `~/.uvx/config.json`）。后续执行命令时，将自动使用此固定域名，除非用户使用特定标志（如 `--reset-domain`）来清除设置并重新选择。",
        "testStrategy": "1. **`cloudflared` 安装验证**：在一个未安装 `cloudflared` 的环境中运行命令，确认系统能正确检测缺失、提示用户并成功完成安装。在已安装的环境中，确认安装步骤被跳过。2. **交互流程验证**：运行命令，确认域名选择菜单正常显示。选择“随机域名”，验证是否成功创建了 `*.trycloudflare.com` 隧道。3. **认证与域名列表验证**：在未登录状态下选择“从账户选择域名”，验证是否自动触发了登录流程。登录后，验证菜单中是否只正确列出了测试账户下配置了 A 记录的域名，并确认仅有 CNAME 或 AAAA 记录的域名被过滤掉。选择其中一个域名，验证隧道是否使用该域名成功建立。4. **域名固定功能验证**：选择一个域名并选择“固定”它。检查本地配置文件，确认域名已被正确保存。退出并重新运行命令，验证程序是否直接使用了该固定域名而没有显示选择菜单。最后，使用 `--reset-domain` 标志运行命令，确认配置被清除且选择菜单再次出现。",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "实现 `cloudflared` 的自动检测与安装脚本",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "使用 `inquirer.js` 构建交互式域名选择菜单，提供随机、从账户选择、手动输入三个选项",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "集成 Cloudflare 登录认证流程（复用任务24的功能）",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "实现通过 Cloudflare API 获取域名列表，并实现只筛选 A 记录域名的逻辑",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "实现域名固定功能，将用户选择的域名保存到本地配置文件",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "",
            "description": "添加 `--reset-domain` 命令行标志，用于清除已固定的域名配置",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "",
            "description": "编写并更新单元测试和集成测试，重点验证 A 记录筛选、域名固定和重置功能",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 42,
        "title": "实现 Cloudflare DNS 记录查询功能",
        "description": "开发一个模块，用于通过 Cloudflare API 查询指定域名的 DNS 记录，以判断记录是否已存在。这是智能更新功能的基础。",
        "details": "使用官方 Cloudflare API v4。需要实现一个函数 `findDnsRecord(domain, type)`，该函数会发送 GET 请求到 `https://api.cloudflare.com/client/v4/zones/:zone_id/dns_records`。需要处理 API 认证（使用 API Token 或 Key）。函数应返回找到的记录对象或 null。伪代码：\nasync function findDnsRecord(zoneId, recordName) {\n  const response = await fetch(`.../dns_records?name=${recordName}`, {\n    headers: { 'Authorization': 'Bearer ...' }\n  });\n  const data = await response.json();\n  return data.result.length > 0 ? data.result[0] : null;\n}",
        "testStrategy": "单元测试：模拟 Cloudflare API 响应，测试函数在记录存在和不存在两种情况下的返回值。集成测试：使用真实的 Cloudflare API 凭证和测试域名，验证能否正确查询到记录。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "开发 Cloudflare DNS 记录更新逻辑",
        "description": "基于查询结果，实现更新现有 DNS 记录的功能。如果记录已存在，则调用 API 更新其内容（如 IP 地址）。",
        "details": "实现一个函数 `updateDnsRecord(recordId, data)`。该函数将向 `https://api.cloudflare.com/client/v4/zones/:zone_id/dns_records/:record_id` 发送 PUT 或 PATCH 请求。请求体应包含需要更新的字段，例如 `content` (IP 地址), `proxied` 等。必须处理 API 调用可能出现的错误，如权限不足或无效的记录 ID。",
        "testStrategy": "单元测试：模拟 API 调用，验证请求体是否正确构建。集成测试：使用测试账户，实际更新一条 DNS 记录并验证其内容是否按预期改变。",
        "priority": "high",
        "dependencies": [
          42
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "集成 DNS 智能更新流程与用户反馈",
        "description": "将查询、创建和更新逻辑整合在一起。根据记录是否存在，自动选择执行创建或更新操作，并向用户提供明确的操作反馈（例如“已更新记录”或“已创建新记录”）。",
        "details": "创建一个主函数，该函数首先调用 `findDnsRecord`。如果返回记录，则调用 `updateDnsRecord`；如果返回 null，则调用现有的创建记录函数。使用 `console.log` 或类似的日志库向用户清晰地输出操作结果。实现一个 try-catch 块来捕获整个流程中的错误，并向用户显示友好的错误信息。",
        "testStrategy": "端到端测试：1. 运行命令处理一个不存在的记录，验证是否创建成功并提示用户。2. 再次运行相同命令，验证是否更新成功并提示用户。3. 测试 API 凭证错误等失败场景，验证错误信息是否正确显示。",
        "priority": "medium",
        "dependencies": [
          43
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "实现代理进程后台化运行",
        "description": "修改代理启动逻辑，使其在成功建立连接后，将自身转为后台守护进程（daemonize）运行，并释放当前终端。",
        "details": "可以使用成熟的进程管理库，如 Node.js 环境下的 `pm2` API 模式或 `daemonize-process`。在代理连接成功的回调中，调用库函数将当前进程转为后台运行。需要确保子进程与父进程分离（detached），并且标准输入/输出/错误流被重定向，以避免终端关闭时进程被终止。",
        "testStrategy": "手动测试：启动一个代理，验证终端是否立即返回可用状态。使用 `ps aux | grep uvx-proxy-local` 命令检查代理进程是否仍在后台运行。",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "建立后台进程信息持久化机制",
        "description": "设计并实现一个机制，用于存储和管理所有后台代理进程的信息，包括 PID、本地端口、远程 URL、提供商等。",
        "details": "创建一个本地文件（如 `~/.uvx/processes.json`）来存储一个进程信息对象的数组。当一个进程成功后台化后，将其信息（PID、启动时间、端口等）追加到此文件中。当进程被终止时，应从文件中移除对应条目。需要实现文件读写的锁定机制，以防止并发操作导致数据损坏。",
        "testStrategy": "单元测试：测试进程信息的添加和移除功能。集成测试：启动和停止多个代理进程，检查 `processes.json` 文件的内容是否与实际运行的进程状态一致。",
        "priority": "high",
        "dependencies": [
          45
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "开发 `uvx-proxy-local list` 命令",
        "description": "实现 `list` 子命令，用于读取持久化的进程信息文件，并以格式化的表格形式在终端中显示所有正在运行的代理进程的详细信息。",
        "details": "该命令将读取 `~/.uvx/processes.json` 文件。为确保信息准确，可以对每个条目通过 `process.kill(pid, 0)` 检查进程是否仍然存活，并过滤掉已不存在的进程。使用 `console.table` 或 `cli-table3` 等库来美化输出，显示的列应包括 PID、本地端口、远程 URL、提供商、状态、启动时间等。",
        "testStrategy": "手动测试：1. 未启动任何代理时运行 `list`，应显示空列表或提示信息。2. 启动一个或多个代理后运行 `list`，验证显示的信息是否完整、准确且格式正确。3. 手动 kill 一个进程后再次运行 `list`，验证该进程是否不再显示。",
        "priority": "high",
        "dependencies": [
          46
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "实现 `uvx-proxy-local kill <pid>` 命令",
        "description": "实现 `kill` 子命令，允许用户通过提供进程 ID (PID) 来直接、快速地终止一个指定的后台代理进程。",
        "details": "该命令接收一个 PID 作为参数。首先，从 `processes.json` 文件中查找该 PID。如果找到，使用 `process.kill(pid, 'SIGTERM')` 发送终止信号。实现一个等待和重试机制，如果在几秒钟后进程仍未退出，则强制使用 `SIGKILL`。成功终止后，从 `processes.json` 文件中移除该进程的记录。",
        "testStrategy": "手动测试：1. 启动一个代理并获取其 PID。2. 运行 `uvx-proxy-local kill <pid>`，验证进程是否被终止（通过 `ps` 命令确认）。3. 运行 `list` 命令，验证该进程已从列表中移除。4. 尝试 kill 一个不存在的 PID，验证是否返回适当的错误信息。",
        "priority": "medium",
        "dependencies": [
          46
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "构建交互式进程终止界面",
        "description": "当 `uvx-proxy-local kill` 命令不带参数运行时，启动一个交互式界面，列出所有运行中的代理，并允许用户使用上下键选择一个或多个进程进行终止。",
        "details": "使用 `inquirer` 或 `enquirer` 库。首先调用与 `list` 命令类似的功能获取正在运行的进程列表。然后，使用 `inquirer` 的 `checkbox` 或 `list` 提示类型来展示这些进程。用户可以使用空格键进行多选（如果使用 `checkbox`），或上下键单选。界面应清晰地显示每个选项的关键信息（如 PID 和 URL）。",
        "testStrategy": "手动测试：运行 `uvx-proxy-local kill`。1. 验证是否显示了所有正在运行的代理列表。2. 验证上下箭头键是否能正常移动光标。3. 验证空格键（或回车键）是否能正确选择/取消选择进程。",
        "priority": "high",
        "dependencies": [
          47
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "完成交互式终止的确认与执行逻辑",
        "description": "在用户于交互式界面中选择进程后，提供一个确认步骤，并在用户确认后，批量终止所有选定的进程。",
        "details": "在用户完成选择并按回车后，使用 `inquirer` 的 `confirm` 提示类型，向用户显示将要终止的进程列表并请求确认。如果用户确认，则遍历选中的进程 PID 列表，依次调用 `kill <pid>` 的核心逻辑来终止它们。为用户提供清晰的批量操作结果反馈，例如“成功终止 3 个进程”。",
        "testStrategy": "手动测试：1. 在交互式界面中选择一个或多个进程。2. 在确认步骤中选择“是”，验证所有选定进程是否被终止。3. 再次启动进程，在确认步骤中选择“否”，验证没有任何进程被终止。",
        "priority": "medium",
        "dependencies": [
          48,
          49
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "实现 `uvx-proxy-local status` 命令并完善 CLI",
        "description": "开发 `status` 命令以显示更详细的代理状态信息，并对整个命令行接口进行最终整合和测试，确保所有命令和选项都按预期工作。",
        "details": "`status` 命令可以复用 `list` 的逻辑，但提供更详尽的信息，例如内存/CPU 使用率（可通过 `pidusage` 等库获取）、总运行时间、流量统计（如果可实现）等。最后，检查所有命令 (`list`, `kill`, `status`) 的帮助信息、参数解析和错误处理，确保 CLI 的一致性和易用性。",
        "testStrategy": "端到端测试：全面测试所有命令及其组合。例如，启动代理 -> `list` 查看 -> `status` 查看详情 -> `kill <pid>` 终止一个 -> `kill` 交互式终止其余的。验证每个步骤的输出是否符合预期，并检查边缘情况（如列表为空、PID 无效等）。",
        "priority": "low",
        "dependencies": [
          47
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "实现基于 API 令牌的 Cloudflare 认证与验证",
        "description": "重构现有的 Cloudflare 自定义 DNS 认证流程，废弃复杂的浏览器登录方式，转而采用更稳定、更直接的 API 令牌验证机制，以解决登录问题并提升用户体验。",
        "details": "此任务旨在彻底改造 Cloudflare 的身份验证模块，核心是实现一个最小化的 API 令牌验证流程。1. **弃用旧流程**：移除或标记为废弃当前基于 `cloudflared tunnel login` 的浏览器认证逻辑（源于任务24），因为它不稳定且难以自动化。2. **引入 API 令牌配置**：用户将通过 CLI 交互或配置文件（例如 `~/.uvx/config.json`）提供 Cloudflare API 令牌。需要实现一个安全的机制来存储此令牌，确保文件权限正确（如 600）。3. **开发核心验证功能**：创建一个名为 `verifyCloudflareToken(token)` 的异步函数。此函数的唯一职责是验证令牌的有效性。最佳实践是调用 Cloudflare API 的 `/client/v4/user/tokens/verify` 端点。如果该令牌有效，API 将返回成功状态。这是一个轻量级的只读操作，非常适合用于快速验证。4. **集成交互式提示**：当用户首次执行需要认证的操作时（例如，从 Cloudflare 账户选择域名），系统应检查令牌是否存在且有效。如果无效或缺失，应启动一个交互式提示（可使用 `inquirer.js`），引导用户输入他们的 API 令牌，并提供一个清晰的链接和说明，指导用户在 Cloudflare 仪表板上创建具有正确权限（至少需要 `Zone:Zone:Read` 和 `Zone:DNS:Edit`）的令牌。5. **重构现有模块**：修改任务41中实现的域名选择功能和任务42/43中的 DNS 操作函数，使其不再依赖 `cloudflared` 的登录状态，而是直接使用已验证并存储的 API 令牌来初始化 Cloudflare API 客户端。",
        "testStrategy": "1. **单元测试**：为 `verifyCloudflareToken` 函数编写测试用例。使用模拟的 API 响应来测试三种情况：a) 提供一个有效的令牌，函数应返回 true；b) 提供一个格式错误或无效的令牌，函数应返回 false 并记录错误；c) 提供一个权限不足的令牌，函数应返回 false 并提示权限问题。2. **集成测试**：在一个干净的环境中（没有配置令牌），运行需要认证的命令（如 `uvx proxy-local --list-domains`）。验证系统是否正确地提示用户输入 API 令牌。3. **端到端测试（有效令牌）**：按照提示输入一个有效的 Cloudflare API 令牌。验证令牌是否被正确保存，并且命令是否成功执行（例如，正确列出账户下的域名）。之后再次运行相同命令，验证系统不再提示输入令牌，而是直接使用已保存的令牌。4. **端到端测试（无效令牌）**：在提示时输入一个无效的令牌。验证系统是否显示清晰的错误信息“令牌无效或权限不足”，并终止操作。5. **配置管理测试**：实现并测试一个命令（如 `uvx config --reset-cloudflare-token`）来清除已存储的令牌，并验证清除后再次运行命令会重新触发输入提示。",
        "status": "done",
        "dependencies": [
          24,
          41,
          42,
          43
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "废弃旧版浏览器认证并实现安全的 API 令牌存储机制",
            "description": "移除或标记为废弃当前基于 `cloudflared tunnel login` 的认证逻辑（源于任务24），并实现一个用于读取和写入 Cloudflare API 令牌到配置文件（如 `~/.uvx/config.json`）的模块，同时确保文件权限被安全地设置为 600。",
            "dependencies": [],
            "details": "此任务是重构的第一步，旨在清理旧代码并为新的令牌机制奠定基础。需要创建一个配置管理模块，包含 `saveToken(token)` 和 `loadToken()` 两个核心函数。`saveToken` 函数在写入令牌后，必须使用 Node.js 的 `fs.chmodSync` 或等效方法将文件权限设置为 600，以保护令牌不被其他用户读取。",
            "status": "done",
            "testStrategy": "1. 单元测试：验证 `saveToken` 函数是否正确写入令牌并设置了 600 文件权限。2. 单元测试：验证 `loadToken` 函数在文件存在时能正确读取令牌，在文件不存在时返回 null。3. 代码审查：确认所有调用 `cloudflared tunnel login` 的代码已被移除或被新逻辑替代。"
          },
          {
            "id": 2,
            "title": "开发核心 API 令牌验证函数",
            "description": "创建一个独立的异步函数 `verifyCloudflareToken(token)`，该函数通过调用 Cloudflare API 的 `/client/v4/user/tokens/verify` 端点来验证所提供令牌的有效性、状态和权限。",
            "dependencies": [],
            "details": "此函数是认证流程的核心。它应接受一个字符串类型的令牌作为参数，并返回一个布尔值或包含状态信息的对象。函数内部需使用 `axios` 或 `node-fetch` 发起一个 `GET` 请求到 Cloudflare API。必须正确处理网络错误、API 错误（如 401 未授权、403 权限不足）和成功响应（HTTP 200）。",
            "status": "done",
            "testStrategy": "为 `verifyCloudflareToken` 函数编写单元测试，使用 `moxios` 或 `nock` 模拟 API 响应：a) 模拟有效令牌的成功响应（返回 true）；b) 模拟无效或过期令牌的失败响应（返回 false）；c) 模拟网络错误（抛出异常或返回 false）；d) 模拟权限不足的令牌响应。"
          },
          {
            "id": 3,
            "title": "实现交互式 API 令牌输入与引导流程",
            "description": "当系统检测到需要认证但令牌缺失或无效时，启动一个交互式命令行提示，引导用户输入他们的 Cloudflare API 令牌，并提供创建令牌的详细说明。",
            "dependencies": [
              "52.2"
            ],
            "details": "使用 `inquirer.js` 库创建一个用户友好的提示。提示信息应清晰地告知用户需要一个 API 令牌，并提供一个可点击的链接（https://dash.cloudflare.com/profile/api-tokens）指向 Cloudflare 仪表板的令牌创建页面。同时，明确指出令牌所需的最小权限：`Zone:Zone:Read` 和 `Zone:DNS:Edit`。",
            "status": "done",
            "testStrategy": "1. 手动集成测试：在一个没有配置令牌的环境中，运行需要认证的命令，验证交互式提示是否按预期触发。2. 验证输入：输入一个虚构的令牌，确认系统会接收并尝试验证它。3. 验证引导信息：检查提示中显示的链接和权限说明是否清晰、准确。"
          },
          {
            "id": 4,
            "title": "整合完整的令牌获取与验证工作流",
            "description": "将令牌的读取、验证和交互式输入提示整合为一个统一的、可复用的认证函数，例如 `getValidCloudflareToken()`。此函数将作为所有需要认证操作的入口点。",
            "dependencies": [
              "52.1",
              "52.2",
              "52.3"
            ],
            "details": "实现 `getValidCloudflareToken()` 异步函数。其逻辑应为：1. 尝试从配置文件加载令牌（调用子任务52.1的功能）。2. 如果找到令牌，调用 `verifyCloudflareToken`（子任务52.2）进行验证。3. 如果令牌有效，返回该令牌。4. 如果令牌不存在或无效，则触发交互式提示（子任务52.3）让用户输入新令牌。5. 获取新令牌后，先验证其有效性，验证通过后将其保存到配置文件（子任务52.1），然后返回该令牌。如果用户输入了无效令牌，应允许重试。",
            "status": "done",
            "testStrategy": "1. 集成测试（无令牌场景）：在一个干净的环境中调用该函数，验证它是否能完整地走完“提示输入 -> 验证 -> 保存 -> 返回令牌”的流程。2. 集成测试（有令牌场景）：预先配置一个有效的令牌，调用函数，验证它是否能直接读取并返回令牌，跳过交互提示。3. 集成测试（无效令牌场景）：预先配置一个无效的令牌，调用函数，验证它是否会提示用户输入新令牌。"
          },
          {
            "id": 5,
            "title": "重构域名选择与 DNS 操作模块以使用新认证机制",
            "description": "修改任务41（域名选择功能）和任务42/43（DNS 操作函数）中的相关代码，使其不再依赖旧的登录状态，而是统一调用新的 `getValidCloudflareToken()` 函数来获取令牌并初始化 Cloudflare API 客户端。",
            "dependencies": [
              "52.4"
            ],
            "details": "在需要与 Cloudflare API 交互的地方（如列出域名、查询/更新 DNS 记录），将原有的认证检查替换为对 `getValidCloudflareToken()` 的调用。获取到有效令牌后，将其用于设置 API 请求的 `Authorization` 头（例如 `Bearer ${token}`）。确保所有相关的 API 调用都使用此令牌进行鉴权。",
            "status": "done",
            "testStrategy": "1. 端到端测试（域名选择）：运行 `uvx proxy-local` 并选择从 Cloudflare 账户选择域名。验证系统是否通过新的令牌机制成功获取并列出域名。2. 端到端测试（DNS 更新）：选择一个自定义域名进行代理，验证系统是否能使用新令牌成功查询和更新 DNS A 记录。3. 回归测试：确保废弃旧认证逻辑后，原有的功能（如临时隧道）不受影响。"
          }
        ]
      },
      {
        "id": 53,
        "title": "修复 Cloudflare 命名隧道的 DNS 路由配置失败问题",
        "description": "修复在使用 API 令牌成功创建命名隧道后，因 DNS 路由配置失败而导致整个设置流程中断的错误。此任务将诊断并纠正 DNS 记录创建逻辑，确保 CNAME 记录能被正确添加到用户的 Cloudflare 账户中。",
        "details": "此任务的核心是解决 API 令牌认证通过后，`cloudflared` 创建命名隧道成功但配置 DNS 路由失败的问题。首先，需要增强日志记录功能，在执行 `cloudflared tunnel route dns` 命令前后捕获完整的命令、参数以及 `stdout` 和 `stderr` 输出，以便精确诊断失败原因。其次，审查并重构获取 Zone ID 的逻辑，确保能根据用户提供的域名准确地从 Cloudflare API (`/client/v4/zones`) 匹配到正确的区域。然后，实现一个 API 权限预检功能：在尝试创建路由前，使用令牌调用一个只读的 DNS API 端点，验证其是否具备对目标 Zone 的 `Zone:DNS:Edit` 权限，若无则提前向用户报错。最后，修复核心的 DNS 路由创建逻辑，确保使用隧道的唯一 ID 而非名称来执行路由命令 (`cloudflared tunnel route dns <TUNNEL_ID> <HOSTNAME>`)，并改进错误处理机制，能解析 `cloudflared` 返回的特定错误码，为用户提供更清晰的指引，例如提示检查 API 令牌权限。",
        "testStrategy": "测试策略分为集成测试和单元测试。1. **集成测试（失败场景）**：使用一个仅有隧道创建权限但缺少 `Zone:DNS:Edit` 权限的真实 Cloudflare API 令牌。执行创建命名隧道流程，验证程序是否在 DNS 路由阶段失败，并返回清晰、可操作的权限不足错误提示。2. **集成测试（成功场景）**：使用一个具备完整权限（包括 `Zone:DNS:Edit` 和 `Account:Cloudflare Tunnel:Edit`）的 API 令牌。执行创建流程，验证隧道创建成功，并且在 Cloudflare DNS 管理面板中，指定的域名下成功创建了指向 `<tunnel-id>.cfargotunnel.com` 的 CNAME 记录。3. **集成测试（冲突场景）**：在 Cloudflare 上为目标域名手动创建一个 A 记录。再次运行创建流程，验证系统能够正确处理已存在的记录（覆盖或报错），并确保应用状态一致。4. **单元测试**：为错误解析逻辑编写测试用例，模拟 `cloudflared` 返回的各种错误输出（如无效 Zone ID、认证失败等），验证函数能正确解析并分类这些错误。",
        "status": "done",
        "dependencies": [
          24,
          41,
          42,
          43,
          52
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "为 Cloudflare 隧道集成交互式 DNS 冲突处理",
        "description": "在创建 Cloudflare 命名隧道时，自动检测并处理已存在的 DNS 记录。通过交互式菜单为用户提供更新、重命名、使用随机域名或退出的选项，提升用户体验。",
        "details": "此任务旨在增强 CloudflareProvider 的 createTunnel 方法，以优雅地处理 DNS CNAME 记录已存在的常见冲突。当 `cloudflared tunnel route dns` 命令因记录重复而失败时（通常返回包含“CNAME record with that name already exists”和 API 代码 81057 的错误），程序不应直接退出，而应捕获此特定错误并启动一个交互式流程。\n1. **错误检测**：在 `CloudflareProvider` 的 `try...catch` 块中，精确匹配 `stderr` 输出，以识别 DNS 记录已存在的特定错误。\n2. **交互式提示**：使用 `inquirer` 或类似库向用户展示一个清晰的菜单，包含以下四个选项：\n   - **更新现有记录**：将现有 CNAME 记录指向新的隧道。\n   - **输入新的子域名**：允许用户提供一个不同的主机名。\n   - **使用随机域名**：回退到创建临时的 `trycloudflare.com` 隧道。\n   - **退出**：安全地终止程序。\n3. **逻辑实现**：\n   - **更新**：重新执行 `cloudflared tunnel route dns` 命令，但附加 `--overwrite-dns` 标志以强制更新记录。\n   - **新子域名**：提示用户输入新的主机名，然后使用新名称重新尝试 DNS 路由逻辑。\n   - **随机域名**：调用内部用于创建临时隧道的逻辑（源于任务23），并返回其 URL。\n   - **退出**：调用 `process.exit(0)` 正常退出。\n4. **代码结构**：建议将冲突处理逻辑封装在一个私有辅助方法中，如 `_handleDnsConflict(tunnelId, failedHostname)`，以保持 `createTunnel` 方法的整洁。",
        "testStrategy": "测试需要一个配置了有效 API 令牌的 Cloudflare 账户。\n1. **准备工作**：在 Cloudflare DNS 管理面板中，为测试域名手动创建一个 CNAME 记录，例如 `test-conflict.yourdomain.com`。\n2. **冲突触发测试**：运行 `uvx proxy-local` 命令并尝试使用 `test-conflict.yourdomain.com` 创建隧道。验证程序是否捕获了错误并成功显示了包含四个选项的交互式提示。\n3. **“更新”选项测试**：在提示中选择“更新现有记录”。验证命令是否成功完成，并在 Cloudflare 面板中检查该 CNAME 记录是否已更新，指向新的隧道 ID。\n4. **“新子域名”选项测试**：再次触发冲突，在提示中选择“输入新的子域名”。输入一个未使用的主机名（如 `new-test.yourdomain.com`），验证隧道是否使用新名称成功创建。\n5. **“随机域名”选项测试**：再次触发冲突，在提示中选择“使用随机域名”。验证程序是否成功创建并输出一个 `*.trycloudflare.com` 的临时隧道 URL。\n6. **“退出”选项测试**：再次触发冲突，在提示中选择“退出”。验证程序是否干净地终止，没有创建任何隧道或 DNS 记录。\n7. **无冲突测试**：使用一个全新的、不存在的子域名运行命令，验证程序是否直接成功创建隧道，不显示任何冲突提示。",
        "status": "done",
        "dependencies": [
          53,
          52,
          24,
          23
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "修复 Cloudflare API 令牌缓存与验证逻辑",
        "description": "修复一个关键错误：即使用户已成功保存新的 Cloudflare API 令牌，程序重启后仍错误地提示认证失败。此任务将全面调试令牌的存储、读取和验证流程，确保认证状态的持久性。",
        "details": "此任务旨在解决 Cloudflare API 令牌在本地存储后，应用重启时无法正确加载和验证的问题。根本原因可能是文件读写逻辑错误，或内存中的状态与磁盘上的状态不同步。\n1. **增强日志记录**：在令牌处理的整个生命周期中添加详细的调试日志。包括：令牌保存到配置文件的路径和内容、应用启动时从文件读取的令牌值、发送到 Cloudflare API 进行验证的令牌（屏蔽部分关键字符）。\n2. **审查存储逻辑**：仔细检查将令牌写入配置文件的代码（例如 `~/.uvx/config.json`）。确保文件写入是同步操作或正确处理了异步回调/Promise，防止应用在文件完全写入前退出。验证文件权限是否正确设置。\n3. **审查加载逻辑**：检查应用启动时读取配置文件的逻辑。确保在进行任何需要认证的操作之前，令牌已经被正确加载到内存中的配置对象中。防止使用过时或默认的空值。\n4. **验证流程校对**：确认调用 Cloudflare 的 `/user/tokens/verify` 端点的函数（源于任务52）始终使用从文件中最新读取的令牌。修复任何可能导致内存中旧令牌被错误重用的状态管理问题。\n5. **实施修复**：根据调试结果，修复核心问题。很可能需要确保在用户输入新令牌并保存后，立即更新应用内部的配置状态，而不仅仅是写入文件。",
        "testStrategy": "测试需要一个有效的 Cloudflare API 令牌。\n1. **复现错误**：在一个干净的环境中（删除 `~/.uvx/config.json`），运行需要认证的命令。当提示输入令牌时，提供一个有效的令牌。确认操作成功。然后，完全关闭并重启应用程序。验证问题是否复现：程序不应再次要求输入令牌。\n2. **验证修复（有效令牌）**：应用修复后，重复步骤1。程序重启后，应能自动、静默地使用已保存的令牌完成认证，并直接执行后续操作，不再提示输入。\n3. **验证无效令牌处理**：手动编辑配置文件，将令牌修改为一个无效的字符串。启动程序。程序应能正确检测到令牌无效（通过API验证失败），并友好地提示用户输入一个新的有效令牌。\n4. **验证令牌更新流程**：在程序运行期间，通过相应命令更新为一个新的有效令牌。重启程序，验证新令牌是否生效。同时，检查配置文件中的内容是否已正确更新为新令牌。",
        "status": "done",
        "dependencies": [
          52,
          53,
          24
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 56,
        "title": "修复 DNS 冲突处理的交互式菜单未触发问题",
        "description": "调试并修复在 Cloudflare 命名隧道创建过程中，检测到 DNS 记录冲突时交互式选择菜单未能正确显示给用户的问题。确保 `_handleDnsConflict` 方法能够可靠地暂停执行并等待用户输入。",
        "details": "此任务旨在解决在检测到 DNS 记录冲突后，本应由任务54实现的交互式菜单没有被触发的严重错误。根本原因很可能与异步流程控制或子进程的输入/输出流干扰有关。\n1. **增强日志记录**：在 `CloudflareProvider` 的 `_handleDnsConflict` 方法的入口和出口，以及调用 `inquirer` 之前，添加详细的调试日志。记录捕获到的具体错误信息和程序状态，以确认该方法是否被正确调用。\n2. **审查异步流程**：仔细检查 `_handleDnsConflict` 方法及其调用链。确保所有返回 Promise 的函数都被正确地 `await`。特别注意 `cloudflared` 子进程的执行和错误捕获逻辑，确保在尝试显示交互式提示之前，子进程已经完全结束，并且其输出流已被处理完毕。\n3. **隔离输入/输出流**：`cloudflared` 子进程的输出可能会干扰 `inquirer` 对 `stdin` 和 `stdout` 的控制。在调用 `inquirer.prompt()` 之前，确认子进程的 I/O 流已经被关闭或不再活动。可以尝试在调用提示前加入一个短暂的延迟（`setTimeout`）作为诊断手段，但这不应是最终解决方案。\n4. **实施修复**：根据诊断结果，实施修复。这可能包括添加缺失的 `await` 关键字，重构 Promise 链以确保顺序执行，或者更明确地管理子进程的生命周期和 I/O。\n5. **添加环境检查**：为增强健壮性，在调用 `inquirer` 之前增加一个检查，确认当前环境是否为交互式终端（`process.stdout.isTTY`）。如果不是，则应跳过交互式提示，直接以失败告终并打印明确的错误信息。",
        "testStrategy": "测试需要一个已配置有效 Cloudflare API 令牌的环境。\n1. **复现错误**：遵循任务54的测试准备步骤，在 Cloudflare DNS 中手动创建一个 CNAME 记录（例如 `conflict.yourdomain.com`）。运行命令尝试使用完全相同的主机名创建隧道。验证当前行为：程序应直接跳过交互式菜单，并可能错误地继续执行或失败，而不是显示选项。\n2. **验证修复**：应用修复补丁后，重复步骤1。程序现在必须能够正确地暂停，并清晰地显示包含“更新现有记录”、“输入新的子域名”、“使用随机域名”和“退出”四个选项的交互式菜单。\n3. **功能回归测试**：系统地测试交互式菜单的每一个选项，确保其功能未受影响：\n   - 选择“更新现有记录”，验证命令成功执行，并且 Cloudflare DNS 面板中的记录被正确更新。\n   - 选择“输入新的子域名”，提供一个有效的新名称，验证隧道是否以新名称成功创建。\n   - 选择“使用随机域名”，验证程序是否回退到创建临时的 `trycloudflare.com` 隧道。\n   - 选择“退出”，验证程序是否干净地终止，没有创建任何隧道或DNS记录。\n4. **非交互式环境测试**：通过管道重定向命令的输出（例如 `uvx proxy-local ... | cat`）来模拟非 TTY 环境。验证程序是否能检测到此环境，不尝试显示菜单，并打印一条指示无法进行交互式操作的错误信息后退出。",
        "status": "done",
        "dependencies": [
          54,
          53,
          24
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 57,
        "title": "实施版本发布流程",
        "description": "建立一个标准化、自动化的流程，用于更新版本号、生成变更日志、构建、测试并将新版本的软件包发布到 npm。",
        "details": "此任务旨在规范化并简化版本发布过程，减少手动操作和潜在错误。我们将采用业界最佳实践，如语义化版本（SemVer）和约定式提交（Conventional Commits）。\n1. **引入版本管理工具**：集成 `standard-version` 工具（或类似工具如 `release-it`）。该工具可以根据约定式提交消息自动确定版本号（补丁、次版本或主版本）、生成 `CHANGELOG.md` 文件，并创建和推送 Git 标签。\n2. **配置 npm 脚本**：在 `package.json` 中创建一个名为 `release` 的新脚本。此脚本将串联整个发布流程，确保每一步都按顺序执行。\n   ```json\n   \"scripts\": {\n     \"release\": \"npm test && standard-version && git push --follow-tags origin main && npm publish\"\n   }\n   ```\n3. **流程分解**：\n   - `npm test`：在发布前运行所有测试套件，确保代码质量和功能稳定性。\n   - `standard-version`：核心步骤。它会读取 git 提交历史，自动提升 `package.json` 中的版本号，基于提交记录更新 `CHANGELOG.md`，然后提交这些更改并创建一个新的版本标签（例如 `v1.2.3`）。\n   - `git push --follow-tags origin main`：将新的提交和版本标签推送到远程 Git 仓库。\n   - `npm publish`：将软件包构建并发布到 npm 公共注册中心。此步骤要求执行者已通过 `npm login` 登录或在 CI/CD 环境中配置了 `NPM_TOKEN`。\n4. **CI/CD 集成（可选）**：为了实现完全自动化，可以配置一个持续集成/持续部署（CI/CD）管道（例如使用 GitHub Actions）。当代码合并到主分支或手动触发工作流时，该管道将自动执行 `npm run release` 脚本。",
        "testStrategy": "由于此任务是关于流程的建立，测试策略侧重于验证该流程的每个环节是否都能正确、可靠地工作。\n1. **Dry Run 验证**：在不实际修改文件或发布的情况下，执行 `standard-version --dry-run` 命令。检查其输出，验证工具是否能正确解析提交历史，并预测出正确的版本号和变更日志条目。\n2. **本地模拟发布**：在本地特性分支上，完整运行 `npm run release` 脚本，但将最后一步替换为 `npm publish --dry-run`。验证以下几点：\n   - `package.json` 中的版本号是否已正确更新。\n   - `CHANGELOG.md` 文件是否已生成并包含了最新的提交信息。\n   - 是否已在本地成功创建了对应的 Git 标签。\n3. **预发布（Beta）测试**：执行一个到 npm `beta` 频道的预发布。使用命令 `standard-version --prerelease beta` 创建一个预发布版本（如 `v1.2.3-beta.0`），然后使用 `npm publish --tag beta` 将其发布。在一个新的测试项目中安装此 beta 版本，验证其功能是否符合预期。\n4. **首次生产发布监控**：在执行第一次正式发布时，密切监控每个步骤的控制台输出。发布成功后，立即访问 npmjs.com 上的包页面，确认新版本已上线。最后，通过 `npm install <package-name>@latest` 在一个干净的环境中安装最新版本，进行最终的功能验证。",
        "status": "in-progress",
        "dependencies": [
          56,
          55,
          54,
          53,
          52
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-05T13:44:42.534Z",
      "updated": "2025-09-07T16:11:48.516Z",
      "description": "Tasks for master context"
    }
  }
}